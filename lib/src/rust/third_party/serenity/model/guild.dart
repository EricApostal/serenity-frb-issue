// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../utils.dart';
import 'channel.dart';
import 'gateway.dart';
import 'id.dart';
import 'misc.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'permissions.dart';
import 'sticker.dart';
import 'timestamp.dart';
import 'user.dart';
import 'voice.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CalculatePermissions`, `GuildPrune`, `GuildWidget`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `cmp`, `cmp`, `cmp`, `cmp`, `cmp`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `partial_cmp`, `partial_cmp`, `partial_cmp`, `partial_cmp`, `partial_cmp`, `partial_cmp`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `add_member`, `audit_logs`, `automod_rule`, `automod_rules`, `ban_with_reason`, `ban`, `bans`, `bulk_ban`, `channel_id_from_name`, `channels`, `create_automod_rule`, `create_channel`, `create_command`, `create_emoji`, `create_integration`, `create_role`, `create_scheduled_event`, `create_sticker`, `create`, `current_user_member`, `delete_automod_rule`, `delete_command`, `delete_emoji`, `delete_integration`, `delete_role`, `delete_scheduled_event`, `delete_sticker`, `delete`, `edit_automod_rule`, `edit_command_permissions`, `edit_command`, `edit_emoji`, `edit_member`, `edit_mfa_level`, `edit_nickname`, `edit_role_position`, `edit_role`, `edit_scheduled_event`, `edit_sticker`, `edit_welcome_screen`, `edit_widget`, `edit`, `emoji`, `emojis`, `get_active_threads`, `get_command_permissions`, `get_command`, `get_commands_permissions`, `get_commands_with_localizations`, `get_commands`, `get`, `greater_member_hierarchy`, `integrations`, `invites`, `kick_with_reason`, `kick`, `leave`, `member`, `members_with_status`, `members`, `move_member`, `prune_count`, `reorder_channels`, `scheduled_event_users_optioned`, `scheduled_event_users`, `scheduled_event`, `scheduled_events`, `search_members`, `set_commands`, `shard_id`, `start_integration_sync`, `start_prune`, `unban`, `vanity_url`, `webhooks`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AfkMetadata>>
abstract class AfkMetadata implements RustOpaqueInterface {
  ChannelId get afkChannelId;

  AfkTimeout get afkTimeout;

  set afkChannelId(ChannelId afkChannelId);

  set afkTimeout(AfkTimeout afkTimeout);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AfkTimeout>>
abstract class AfkTimeout implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ban>>
abstract class Ban implements RustOpaqueInterface {
  String? get reason;

  User get user;

  set reason(String? reason);

  set user(User user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DefaultMessageNotificationLevel>>
abstract class DefaultMessageNotificationLevel implements RustOpaqueInterface {
  static Future<DefaultMessageNotificationLevel> default_() =>
      RustLib.instance.api
          .serenityModelGuildDefaultMessageNotificationLevelDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExplicitContentFilter>>
abstract class ExplicitContentFilter implements RustOpaqueInterface {
  static Future<ExplicitContentFilter> default_() =>
      RustLib.instance.api.serenityModelGuildExplicitContentFilterDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Guild>>
abstract class Guild implements RustOpaqueInterface, ArgumentConvert {
  AfkMetadata? get afkMetadata;

  ApplicationId? get applicationId;

  BigInt? get approximateMemberCount;

  BigInt? get approximatePresenceCount;

  String? get banner;

  Map<ChannelId, GuildChannel> get channels;

  DefaultMessageNotificationLevel get defaultMessageNotifications;

  String? get description;

  ImageHash? get discoverySplash;

  Map<EmojiId, Emoji> get emojis;

  ExplicitContentFilter get explicitContentFilter;

  List<String> get features;

  ImageHash? get icon;

  ImageHash? get iconHash;

  GuildId get id;

  Timestamp get joinedAt;

  bool get large;

  BigInt? get maxMembers;

  BigInt? get maxPresences;

  BigInt? get maxStageVideoChannelUsers;

  BigInt? get maxVideoChannelUsers;

  BigInt get memberCount;

  Map<UserId, Member> get members;

  MfaLevel get mfaLevel;

  String get name;

  NsfwLevel get nsfwLevel;

  UserId get ownerId;

  String get preferredLocale;

  bool get premiumProgressBarEnabled;

  BigInt? get premiumSubscriptionCount;

  PremiumTier get premiumTier;

  Map<UserId, Presence> get presences;

  ChannelId? get publicUpdatesChannelId;

  Map<RoleId, Role> get roles;

  ChannelId? get rulesChannelId;

  List<ScheduledEvent> get scheduledEvents;

  ImageHash? get splash;

  List<StageInstance> get stageInstances;

  Map<StickerId, Sticker> get stickers;

  SystemChannelFlags get systemChannelFlags;

  ChannelId? get systemChannelId;

  List<GuildChannel> get threads;

  bool get unavailable;

  String? get vanityUrlCode;

  VerificationLevel get verificationLevel;

  Map<UserId, VoiceState> get voiceStates;

  GuildWelcomeScreen? get welcomeScreen;

  ChannelId? get widgetChannelId;

  bool? get widgetEnabled;

  set afkMetadata(AfkMetadata? afkMetadata);

  set applicationId(ApplicationId? applicationId);

  set approximateMemberCount(BigInt? approximateMemberCount);

  set approximatePresenceCount(BigInt? approximatePresenceCount);

  set banner(String? banner);

  set channels(Map<ChannelId, GuildChannel> channels);

  set defaultMessageNotifications(
    DefaultMessageNotificationLevel defaultMessageNotifications,
  );

  set description(String? description);

  set discoverySplash(ImageHash? discoverySplash);

  set emojis(Map<EmojiId, Emoji> emojis);

  set explicitContentFilter(ExplicitContentFilter explicitContentFilter);

  set features(List<String> features);

  set icon(ImageHash? icon);

  set iconHash(ImageHash? iconHash);

  set id(GuildId id);

  set joinedAt(Timestamp joinedAt);

  set large(bool large);

  set maxMembers(BigInt? maxMembers);

  set maxPresences(BigInt? maxPresences);

  set maxStageVideoChannelUsers(BigInt? maxStageVideoChannelUsers);

  set maxVideoChannelUsers(BigInt? maxVideoChannelUsers);

  set memberCount(BigInt memberCount);

  set members(Map<UserId, Member> members);

  set mfaLevel(MfaLevel mfaLevel);

  set name(String name);

  set nsfwLevel(NsfwLevel nsfwLevel);

  set ownerId(UserId ownerId);

  set preferredLocale(String preferredLocale);

  set premiumProgressBarEnabled(bool premiumProgressBarEnabled);

  set premiumSubscriptionCount(BigInt? premiumSubscriptionCount);

  set premiumTier(PremiumTier premiumTier);

  set presences(Map<UserId, Presence> presences);

  set publicUpdatesChannelId(ChannelId? publicUpdatesChannelId);

  set roles(Map<RoleId, Role> roles);

  set rulesChannelId(ChannelId? rulesChannelId);

  set scheduledEvents(List<ScheduledEvent> scheduledEvents);

  set splash(ImageHash? splash);

  set stageInstances(List<StageInstance> stageInstances);

  set stickers(Map<StickerId, Sticker> stickers);

  set systemChannelFlags(SystemChannelFlags systemChannelFlags);

  set systemChannelId(ChannelId? systemChannelId);

  set threads(List<GuildChannel> threads);

  set unavailable(bool unavailable);

  set vanityUrlCode(String? vanityUrlCode);

  set verificationLevel(VerificationLevel verificationLevel);

  set voiceStates(Map<UserId, VoiceState> voiceStates);

  set welcomeScreen(GuildWelcomeScreen? welcomeScreen);

  set widgetChannelId(ChannelId? widgetChannelId);

  set widgetEnabled(bool? widgetEnabled);

  /// Returns the formatted URL of the guild's banner image, if one exists.
  Future<String?> bannerUrl();

  static Future<Guild> default_() =>
      RustLib.instance.api.serenityModelGuildGuildDefault();

  /// Returns the "default" channel of the guild for the passed user id. (This returns the first
  /// channel that can be read by the user, if there isn't one, returns [`None`])
  Future<GuildChannel?> defaultChannel({required UserId uid});

  /// Returns the guaranteed "default" channel of the guild. (This returns the first channel that
  /// can be read by everyone, if there isn't one, returns [`None`])
  ///
  /// **Note**: This is very costly if used in a server with lots of channels, members, or both.
  Future<GuildChannel?> defaultChannelGuaranteed();

  /// Returns the formatted URL of the guild's icon, if one exists.
  ///
  /// This will produce a WEBP image URL, or GIF if the guild has a GIF icon.
  Future<String?> iconUrl();

  /// Checks if the guild is 'large'.
  ///
  /// A guild is considered large if it has more than 250 members.
  Future<bool> isLarge();

  /// Gets the highest role a [`Member`] of this Guild has.
  ///
  /// Returns None if the member has no roles or the member from this guild.
  Future<Role?> memberHighestRole({required Member member});

  /// Retrieves the first [`Member`] found that matches the name - with an optional discriminator
  /// - provided.
  ///
  /// Searching with a discriminator given is the most precise form of lookup, as no two people
  /// can share the same username *and* discriminator.
  ///
  /// If a member can not be found by username or username#discriminator, then a search will be
  /// done for the nickname. When searching by nickname, the hash (`#`) and everything after it
  /// is included in the search.
  ///
  /// The following are valid types of searches:
  /// - **username**: "zey"
  /// - **username and discriminator**: "zey#5479"
  ///
  /// **Note**: This will only search members that are cached. If you want to search all members
  /// in the guild via the Http API, use [`Self::search_members`].
  Future<Member?> memberNamed({required String name});

  /// Calculate a [`Member`]'s permissions in the guild.
  Future<Permissions> memberPermissions({required Member member});

  /// Retrieves all [`Member`] containing a given [`String`] as either username or nick, with a
  /// priority on username.
  ///
  /// If the substring is "yla", following results are possible:
  /// - "zeyla", "meiyla", "yladenisyla"
  ///
  /// If 'case_sensitive' is false, the following are not found:
  /// - "zeYLa", "meiyLa", "LYAdenislyA"
  ///
  /// `sorted` decides whether the best early match of the search-term should be the criteria to
  /// sort the result. It will look at the account name first, if that does not fit the
  /// search-criteria `substring`, the display-name will be considered.
  ///
  /// For the `substring` "zey" and the unsorted result:
  /// - "azey", "zey", "zeyla", "zeylaa", "zeyzeyzey"
  ///
  /// It would be sorted:
  /// - "zey", "azey", "zeyla", "zeylaa", "zeyzeyzey"
  ///
  /// **Note**: Due to two fields of a [`Member`] being candidates for the searched field,
  /// setting `sorted` to `true` will result in an overhead, as both fields have to be considered
  /// again for sorting.
  ///
  /// **Note**: This will only search members that are cached. If you want to search all members
  /// in the guild via the Http API, use [`Self::search_members`].
  Future<List<(Member, String)>> membersContaining({
    required String substring,
    required bool caseSensitive,
    required bool sorted,
  });

  /// Retrieves all [`Member`] containing a given [`String`] in their nick.
  ///
  /// If the substring is "yla", following results are possible:
  /// - "zeyla", "meiyla", "yladenisyla"
  ///
  /// If 'case_sensitive' is false, the following are not found:
  /// - "zeYLa", "meiyLa", "LYAdenislyA"
  ///
  /// `sort` decides whether the best early match of the search-term should be the criteria to
  /// sort the result.
  ///
  /// For the `substring` "zey" and the unsorted result:
  /// - "azey", "zey", "zeyla", "zeylaa", "zeyzeyzey"
  ///
  /// It would be sorted:
  /// - "zey", "azey", "zeyla", "zeylaa", "zeyzeyzey"
  ///
  /// **Note**: Instead of panicking, when sorting does not find a nick, the username will be
  /// used (this should never happen).
  ///
  /// **Note**: This will only search members that are cached. If you want to search all members
  /// in the guild via the Http API, use [`Self::search_members`].
  Future<List<(Member, String)>> membersNickContaining({
    required String substring,
    required bool caseSensitive,
    required bool sorted,
  });

  /// Retrieves all [`Member`] that start with a given [`String`].
  ///
  /// `sorted` decides whether the best early match of the `prefix` should be the criteria to
  /// sort the result.
  ///
  /// For the `prefix` "zey" and the unsorted result:
  /// - "zeya", "zeyaa", "zeyla", "zeyzey", "zeyzeyzey"
  ///
  /// It would be sorted:
  /// - "zeya", "zeyaa", "zeyla", "zeyzey", "zeyzeyzey"
  ///
  /// **Note**: This will only search members that are cached. If you want to search all members
  /// in the guild via the Http API, use [`Self::search_members`].
  Future<List<(Member, String)>> membersStartingWith({
    required String prefix,
    required bool caseSensitive,
    required bool sorted,
  });

  /// Retrieves a tuple of [`Member`]s containing a given [`String`] in their username as the
  /// first field and the name used for sorting as the second field.
  ///
  /// If the substring is "yla", following results are possible:
  /// - "zeyla", "meiyla", "yladenisyla"
  ///
  /// If 'case_sensitive' is false, the following are not found:
  /// - "zeYLa", "meiyLa", "LYAdenislyA"
  ///
  /// `sort` decides whether the best early match of the search-term should be the criteria to
  /// sort the result.
  ///
  /// For the `substring` "zey" and the unsorted result:
  /// - "azey", "zey", "zeyla", "zeylaa", "zeyzeyzey"
  ///
  /// It would be sorted:
  /// - "zey", "azey", "zeyla", "zeylaa", "zeyzeyzey"
  ///
  /// **Note**: This will only search members that are cached. If you want to search all members
  /// in the guild via the Http API, use [`Self::search_members`].
  Future<List<(Member, String)>> membersUsernameContaining({
    required String substring,
    required bool caseSensitive,
    required bool sorted,
  });

  /// Calculate a [`PartialMember`]'s permissions in the guild.
  ///
  /// # Panics
  ///
  /// Panics if the passed [`UserId`] does not match the [`PartialMember`] id, if user is Some.
  Future<Permissions> partialMemberPermissions({
    required UserId memberId,
    required PartialMember member,
  });

  /// Calculate a [`PartialMember`]'s permissions in a given channel in a guild.
  ///
  /// # Panics
  ///
  /// Panics if the passed [`UserId`] does not match the [`PartialMember`] id, if user is Some.
  Future<Permissions> partialMemberPermissionsIn({
    required GuildChannel channel,
    required UserId memberId,
    required PartialMember member,
  });

  /// Obtain a reference to a role by its name.
  ///
  /// **Note**: If two or more roles have the same name, obtained reference will be one of them.
  ///
  /// # Examples
  ///
  /// Obtain a reference to a [`Role`] by its name.
  ///
  /// ```rust,no_run
  /// # use serenity::model::prelude::*;
  /// # use serenity::prelude::*;
  /// # struct Handler;
  ///
  /// #[serenity::async_trait]
  /// #[cfg(all(feature = "cache", feature = "client"))]
  /// impl EventHandler for Handler {
  ///     async fn message(&self, ctx: Context, msg: Message) {
  ///         if let Some(guild_id) = msg.guild_id {
  ///             if let Some(guild) = guild_id.to_guild_cached(&ctx) {
  ///                 if let Some(role) = guild.role_by_name("role_name") {
  ///                     println!("{:?}", role);
  ///                 }
  ///             }
  ///         }
  ///     }
  /// }
  /// ```
  Future<Role?> roleByName({required String roleName});

  /// Calculate a [`Role`]'s permissions in a given channel in the guild.
  ///
  /// # Errors
  ///
  /// Will return an [`Error::Model`] if the [`Role`] or [`Channel`] is not from this [`Guild`].
  Future<Permissions> rolePermissionsIn({
    required GuildChannel channel,
    required Role role,
  });

  /// Returns the formatted URL of the guild's splash image, if one exists.
  Future<String?> splashUrl();

  /// Calculate a [`Member`]'s permissions in a given channel in the guild.
  Future<Permissions> userPermissionsIn({
    required GuildChannel channel,
    required Member member,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GuildInfo>>
abstract class GuildInfo implements RustOpaqueInterface {
  List<String> get features;

  ImageHash? get icon;

  GuildId get id;

  String get name;

  bool get owner;

  Permissions get permissions;

  set features(List<String> features);

  set icon(ImageHash? icon);

  set id(GuildId id);

  set name(String name);

  set owner(bool owner);

  set permissions(Permissions permissions);

  /// Returns the formatted URL of the guild's icon, if the guild has an icon.
  ///
  /// This will produce a WEBP image URL, or GIF if the guild has a GIF icon.
  Future<String?> iconUrl();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MfaLevel>>
abstract class MfaLevel implements RustOpaqueInterface {
  static Future<MfaLevel> default_() =>
      RustLib.instance.api.serenityModelGuildMfaLevelDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NsfwLevel>>
abstract class NsfwLevel implements RustOpaqueInterface {
  static Future<NsfwLevel> default_() =>
      RustLib.instance.api.serenityModelGuildNsfwLevelDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnavailableGuild>>
abstract class UnavailableGuild implements RustOpaqueInterface {
  GuildId get id;

  bool get unavailable;

  set id(GuildId id);

  set unavailable(bool unavailable);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerificationLevel>>
abstract class VerificationLevel implements RustOpaqueInterface {
  static Future<VerificationLevel> default_() =>
      RustLib.instance.api.serenityModelGuildVerificationLevelDefault();
}

/// The response from [`GuildId::bulk_ban`].
///
/// [Discord docs](https://discord.com/developers/docs/resources/guild#bulk-guild-ban).
class BulkBanResponse {
  /// The users that were successfully banned.
  final List<UserId> bannedUsers;

  /// The users that were not successfully banned.
  final List<UserId> failedUsers;

  const BulkBanResponse({required this.bannedUsers, required this.failedUsers});

  @override
  int get hashCode => bannedUsers.hashCode ^ failedUsers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BulkBanResponse &&
          runtimeType == other.runtimeType &&
          bannedUsers == other.bannedUsers &&
          failedUsers == other.failedUsers;
}
