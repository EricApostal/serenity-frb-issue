// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import 'application.dart';
import 'guild.dart';
import 'id.dart';
import 'misc.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'user.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BotGateway`, `Gateway`, `SessionStartLimit`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `bits`, `bits`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `deserialize`, `deserialize`, `deserialize`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_bits_retain`, `from_bits_retain`, `from`, `from`, `hash`, `hash`, `hash`, `partial_cmp`, `serialize`, `serialize`, `serialize`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Activity>>
abstract class Activity implements RustOpaqueInterface {
  ApplicationId? get applicationId;

  ActivityAssets? get assets;

  List<ActivityButton> get buttons;

  BigInt get createdAt;

  String? get details;

  ActivityEmoji? get emoji;

  ActivityFlags? get flags;

  bool? get instance;

  ActivityType get kind;

  String get name;

  ActivityParty? get party;

  ActivitySecrets? get secrets;

  String? get state;

  ActivityTimestamps? get timestamps;

  Url? get url;

  set applicationId(ApplicationId? applicationId);

  set assets(ActivityAssets? assets);

  set buttons(List<ActivityButton> buttons);

  set createdAt(BigInt createdAt);

  set details(String? details);

  set emoji(ActivityEmoji? emoji);

  set flags(ActivityFlags? flags);

  set instance(bool? instance);

  set kind(ActivityType kind);

  set name(String name);

  set party(ActivityParty? party);

  set secrets(ActivitySecrets? secrets);

  set state(String? state);

  set timestamps(ActivityTimestamps? timestamps);

  set url(Url? url);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ActivityFlags>>
abstract class ActivityFlags implements RustOpaqueInterface {
  static Future<ActivityFlags> default_() =>
      RustLib.instance.api.serenityModelGatewayActivityFlagsDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ActivityType>>
abstract class ActivityType implements RustOpaqueInterface {
  static Future<ActivityType> default_() =>
      RustLib.instance.api.serenityModelGatewayActivityTypeDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GatewayIntents>>
abstract class GatewayIntents implements RustOpaqueInterface {
  /// Shorthand for checking that the set of intents contains the [AUTO_MODERATION_CONFIGURATION]
  /// intent.
  ///
  /// [AUTO_MODERATION_CONFIGURATION]: Self::AUTO_MODERATION_CONFIGURATION
  Future<bool> autoModerationConfiguration();

  /// Shorthand for checking that the set of intents contains the [AUTO_MODERATION_EXECUTION]
  /// intent.
  ///
  /// [AUTO_MODERATION_EXECUTION]: Self::AUTO_MODERATION_EXECUTION
  Future<bool> autoModerationExecution();

  static Future<GatewayIntents> default_() =>
      RustLib.instance.api.serenityModelGatewayGatewayIntentsDefault();

  /// Shorthand for checking that the set of intents contains the [DIRECT_MESSAGE_REACTIONS]
  /// intent.
  ///
  /// [DIRECT_MESSAGE_REACTIONS]: Self::DIRECT_MESSAGE_REACTIONS
  Future<bool> directMessageReactions();

  /// Shorthand for checking that the set of intents contains the [DIRECT_MESSAGE_TYPING] intent.
  ///
  /// [DIRECT_MESSAGE_TYPING]: Self::DIRECT_MESSAGE_TYPING
  Future<bool> directMessageTyping();

  /// Shorthand for checking that the set of intents contains the [DIRECT_MESSAGES] intent.
  ///
  /// [DIRECT_MESSAGES]: Self::DIRECT_MESSAGES
  Future<bool> directMessages();

  /// Shorthand for checking that the set of intents contains the [GUILD_BANS] intent.
  ///
  /// [GUILD_BANS]: Self::GUILD_BANS
  ///
  /// This is the same as calling guild_moderation since Discord changed the name
  Future<bool> guildBans();

  /// Shorthand for checking that the set of intents contains the [GUILD_EMOJIS_AND_STICKERS]
  /// intent.
  ///
  /// [GUILD_EMOJIS_AND_STICKERS]: Self::GUILD_EMOJIS_AND_STICKERS
  Future<bool> guildEmojisAndStickers();

  /// Shorthand for checking that the set of intents contains the [GUILD_INTEGRATIONS] intent.
  ///
  /// [GUILD_INTEGRATIONS]: Self::GUILD_INTEGRATIONS
  Future<bool> guildIntegrations();

  /// Shorthand for checking that the set of intents contains the [GUILD_INVITES] intent.
  ///
  /// [GUILD_INVITES]: Self::GUILD_INVITES
  Future<bool> guildInvites();

  /// Shorthand for checking that the set of intents contains the [GUILD_MEMBERS] intent.
  ///
  /// [GUILD_MEMBERS]: Self::GUILD_MEMBERS
  Future<bool> guildMembers();

  /// Shorthand for checking that the set of intents contains the [GUILD_MESSAGE_REACTIONS]
  /// intent.
  ///
  /// [GUILD_MESSAGE_REACTIONS]: Self::GUILD_MESSAGE_REACTIONS
  Future<bool> guildMessageReactions();

  /// Shorthand for checking that the set of intents contains the [GUILD_MESSAGE_TYPING] intent.
  ///
  /// [GUILD_MESSAGE_TYPING]: Self::GUILD_MESSAGE_TYPING
  Future<bool> guildMessageTyping();

  /// Shorthand for checking that the set of intents contains the [GUILD_MODERATION] intent.
  ///
  /// [GUILD_MODERATION]: Self::GUILD_MODERATION
  Future<bool> guildModeration();

  /// Shorthand for checking that the set of intents contains the [GUILD_PRESENCES] intent.
  ///
  /// [GUILD_PRESENCES]: Self::GUILD_PRESENCES
  Future<bool> guildPresences();

  /// Shorthand for checking that the set of intents contains the [GUILD_SCHEDULED_EVENTS]
  /// intent.
  ///
  /// [GUILD_SCHEDULED_EVENTS]: Self::GUILD_SCHEDULED_EVENTS
  Future<bool> guildScheduledEvents();

  /// Shorthand for checking that the set of intents contains the [GUILD_VOICE_STATES] intent.
  ///
  /// [GUILD_VOICE_STATES]: Self::GUILD_VOICE_STATES
  Future<bool> guildVoiceStates();

  /// Shorthand for checking that the set of intents contains the [GUILD_WEBHOOKS] intent.
  ///
  /// [GUILD_WEBHOOKS]: Self::GUILD_WEBHOOKS
  Future<bool> guildWebhooks();

  /// Shorthand for checking that the set of intents contains the [GUILDS] intent.
  ///
  /// [GUILDS]: Self::GUILDS
  Future<bool> guilds();

  /// Checks if any of the included intents are privileged.
  Future<bool> isPrivileged();

  /// Shorthand for checking that the set of intents contains the [MESSAGE_CONTENT] intent.
  ///
  /// [MESSAGE_CONTENT]: Self::MESSAGE_CONTENT
  Future<bool> messageContent();

  /// Gets all of the intents that aren't considered privileged by Discord.
  static Future<GatewayIntents> nonPrivileged() =>
      RustLib.instance.api.serenityModelGatewayGatewayIntentsNonPrivileged();

  /// Gets all of the intents that are considered privileged by Discord.
  /// Use of these intents will require explicitly whitelisting the bot.
  static Future<GatewayIntents> privileged() =>
      RustLib.instance.api.serenityModelGatewayGatewayIntentsPrivileged();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Presence>>
abstract class Presence implements RustOpaqueInterface {
  List<Activity> get activities;

  ClientStatus? get clientStatus;

  GuildId? get guildId;

  OnlineStatus get status;

  PresenceUser get user;

  set activities(List<Activity> activities);

  set clientStatus(ClientStatus? clientStatus);

  set guildId(GuildId? guildId);

  set status(OnlineStatus status);

  set user(PresenceUser user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PresenceUser>>
abstract class PresenceUser implements RustOpaqueInterface {
  ImageHash? get avatar;

  bool? get bot;

  NonZeroU16? get discriminator;

  String? get email;

  UserId get id;

  bool? get mfaEnabled;

  String? get name;

  UserPublicFlags? get publicFlags;

  bool? get verified;

  set avatar(ImageHash? avatar);

  set bot(bool? bot);

  set discriminator(NonZeroU16? discriminator);

  set email(String? email);

  set id(UserId id);

  set mfaEnabled(bool? mfaEnabled);

  set name(String? name);

  set publicFlags(UserPublicFlags? publicFlags);

  set verified(bool? verified);

  static Future<PresenceUser> default_() =>
      RustLib.instance.api.serenityModelGatewayPresenceUserDefault();

  /// Attempts to convert this [`PresenceUser`] instance into a [`User`].
  ///
  /// If one of [`User`]'s required fields is None in `self`, None is returned.
  Future<User?> intoUser();

  /// Attempts to convert this [`PresenceUser`] instance into a [`User`].
  ///
  /// Will clone individual fields if needed.
  ///
  /// If one of [`User`]'s required fields is None in `self`, None is returned.
  Future<User?> toUser();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ready>>
abstract class Ready implements RustOpaqueInterface {
  PartialCurrentApplicationInfo get application;

  List<UnavailableGuild> get guilds;

  String get resumeGatewayUrl;

  String get sessionId;

  ShardInfo? get shard;

  CurrentUser get user;

  int get version;

  set application(PartialCurrentApplicationInfo application);

  set guilds(List<UnavailableGuild> guilds);

  set resumeGatewayUrl(String resumeGatewayUrl);

  set sessionId(String sessionId);

  set shard(ShardInfo? shard);

  set user(CurrentUser user);

  set version(int version);
}

/// The assets for an activity.
///
/// [Discord docs](https://discord.com/developers/docs/topics/gateway#activity-object-activity-assets).
class ActivityAssets {
  /// The ID for a large asset of the activity, usually a snowflake.
  final String? largeImage;

  /// Text displayed when hovering over the large image of the activity.
  final String? largeText;

  /// The ID for a small asset of the activity, usually a snowflake.
  final String? smallImage;

  /// Text displayed when hovering over the small image of the activity.
  final String? smallText;

  const ActivityAssets({
    this.largeImage,
    this.largeText,
    this.smallImage,
    this.smallText,
  });

  @override
  int get hashCode =>
      largeImage.hashCode ^
      largeText.hashCode ^
      smallImage.hashCode ^
      smallText.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActivityAssets &&
          runtimeType == other.runtimeType &&
          largeImage == other.largeImage &&
          largeText == other.largeText &&
          smallImage == other.smallImage &&
          smallText == other.smallText;
}

/// [Discord docs](https://discord.com/developers/docs/topics/gateway#activity-object-activity-buttons).
class ActivityButton {
  /// The text shown on the button.
  final String label;

  /// The url opened when clicking the button.
  ///
  /// **Note**: Bots cannot access activity button URL.
  final String url;

  const ActivityButton({required this.label, required this.url});

  @override
  int get hashCode => label.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActivityButton &&
          runtimeType == other.runtimeType &&
          label == other.label &&
          url == other.url;
}

/// Representation of an emoji used in a custom status
///
/// [Discord docs](https://discord.com/developers/docs/topics/gateway-events#activity-object-activity-emoji).
class ActivityEmoji {
  /// The name of the emoji.
  final String name;

  /// The id of the emoji.
  final EmojiId? id;

  /// Whether this emoji is animated.
  final bool? animated;

  const ActivityEmoji({required this.name, this.id, this.animated});

  @override
  int get hashCode => name.hashCode ^ id.hashCode ^ animated.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActivityEmoji &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          id == other.id &&
          animated == other.animated;
}

/// Information about an activity's party.
///
/// [Discord docs](https://discord.com/developers/docs/game-sdk/activities#data-models-activityparty-struct).
class ActivityParty {
  /// The ID of the party.
  final String? id;

  /// Used to show the party's current and maximum size.
  final U32Array2? size;

  const ActivityParty({this.id, this.size});

  @override
  int get hashCode => id.hashCode ^ size.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActivityParty &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          size == other.size;
}

/// Secrets for an activity.
///
/// [Discord docs](https://discord.com/developers/docs/topics/gateway#activity-object-activity-secrets).
class ActivitySecrets {
  /// The secret for joining a party.
  final String? join;

  /// The secret for a specific instanced match.
  final String? match;

  /// The secret for spectating an activity.
  final String? spectate;

  const ActivitySecrets({this.join, this.match, this.spectate});

  @override
  int get hashCode => join.hashCode ^ match.hashCode ^ spectate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActivitySecrets &&
          runtimeType == other.runtimeType &&
          join == other.join &&
          match == other.match &&
          spectate == other.spectate;
}

/// Timestamps of when a user started and/or is ending their activity.
///
/// [Discord docs](https://discord.com/developers/docs/game-sdk/activities#data-models-activitytimestamps-struct).
class ActivityTimestamps {
  final BigInt? end;
  final BigInt? start;

  const ActivityTimestamps({this.end, this.start});

  @override
  int get hashCode => end.hashCode ^ start.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActivityTimestamps &&
          runtimeType == other.runtimeType &&
          end == other.end &&
          start == other.start;
}

/// Information detailing the current active status of a [`User`].
///
/// [Discord docs](https://discord.com/developers/docs/topics/gateway#client-status-object).
class ClientStatus {
  final OnlineStatus? desktop;
  final OnlineStatus? mobile;
  final OnlineStatus? web;

  const ClientStatus({this.desktop, this.mobile, this.web});

  @override
  int get hashCode => desktop.hashCode ^ mobile.hashCode ^ web.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientStatus &&
          runtimeType == other.runtimeType &&
          desktop == other.desktop &&
          mobile == other.mobile &&
          web == other.web;
}

class ShardInfo {
  final ShardId id;
  final int total;

  const ShardInfo({required this.id, required this.total});

  @override
  int get hashCode => id.hashCode ^ total.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShardInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          total == other.total;
}
