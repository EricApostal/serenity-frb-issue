// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import 'channel.dart';
import 'guild.dart';
import 'id.dart';
import 'misc.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'timestamp.dart';
import 'user.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `hash`, `partial_cmp`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `create`, `delete`, `delete`, `get`, `shard_id`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Invite>>
abstract class Invite implements RustOpaqueInterface {
  BigInt? get approximateMemberCount;

  BigInt? get approximatePresenceCount;

  InviteChannel get channel;

  String get code;

  Timestamp? get expiresAt;

  InviteGuild? get guild;

  User? get inviter;

  ScheduledEvent? get scheduledEvent;

  InviteStageInstance? get stageInstance;

  ApplicationId? get targetApplication;

  InviteTargetType? get targetType;

  UserId? get targetUser;

  set approximateMemberCount(BigInt? approximateMemberCount);

  set approximatePresenceCount(BigInt? approximatePresenceCount);

  set channel(InviteChannel channel);

  set code(String code);

  set expiresAt(Timestamp? expiresAt);

  set guild(InviteGuild? guild);

  set inviter(User? inviter);

  set scheduledEvent(ScheduledEvent? scheduledEvent);

  set stageInstance(InviteStageInstance? stageInstance);

  set targetApplication(ApplicationId? targetApplication);

  set targetType(InviteTargetType? targetType);

  set targetUser(UserId? targetUser);

  /// Returns a URL to use for the invite.
  ///
  /// # Examples
  ///
  /// Retrieve the URL for an invite with the code `WxZumR`:
  ///
  /// ```rust
  /// # use serenity::json::{json, from_value};
  /// # use serenity::model::prelude::*;
  /// #
  /// # fn main() {
  /// # let invite = from_value::<Invite>(json!({
  /// #     "approximate_member_count": Some(1812),
  /// #     "approximate_presence_count": Some(717),
  /// #     "code": "WxZumR",
  /// #     "channel": {
  /// #         "id": ChannelId::new(1),
  /// #         "name": "foo",
  /// #         "type": ChannelType::Text,
  /// #     },
  /// #     "guild": {
  /// #         "id": GuildId::new(2),
  /// #         "icon": None::<String>,
  /// #         "name": "bar",
  /// #         "splash_hash": None::<String>,
  /// #         "text_channel_count": 7,
  /// #         "voice_channel_count": 3,
  /// #         "features": ["NEWS", "DISCOVERABLE"],
  /// #         "verification_level": 2,
  /// #         "nsfw_level": 0,
  /// #     },
  /// #     "inviter": {
  /// #         "id": UserId::new(3),
  /// #         "username": "foo",
  /// #         "discriminator": "1234",
  /// #         "avatar": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  /// #     },
  /// # })).unwrap();
  /// #
  /// assert_eq!(invite.url(), "https://discord.gg/WxZumR");
  /// # }
  /// ```
  Future<String> url();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteChannel>>
abstract class InviteChannel implements RustOpaqueInterface {
  ChannelId get id;

  ChannelType get kind;

  String get name;

  set id(ChannelId id);

  set kind(ChannelType kind);

  set name(String name);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteGuild>>
abstract class InviteGuild implements RustOpaqueInterface {
  ImageHash? get banner;

  String? get description;

  List<String> get features;

  ImageHash? get icon;

  GuildId get id;

  String get name;

  NsfwLevel get nsfwLevel;

  BigInt? get premiumSubscriptionCount;

  ImageHash? get splash;

  String? get vanityUrlCode;

  VerificationLevel get verificationLevel;

  set banner(ImageHash? banner);

  set description(String? description);

  set features(List<String> features);

  set icon(ImageHash? icon);

  set id(GuildId id);

  set name(String name);

  set nsfwLevel(NsfwLevel nsfwLevel);

  set premiumSubscriptionCount(BigInt? premiumSubscriptionCount);

  set splash(ImageHash? splash);

  set vanityUrlCode(String? vanityUrlCode);

  set verificationLevel(VerificationLevel verificationLevel);

  /// Returns the formatted URL of the guild's splash image, if one exists.
  Future<String?> splashUrl();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteTargetType>>
abstract class InviteTargetType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RichInvite>>
abstract class RichInvite implements RustOpaqueInterface {
  InviteChannel get channel;

  String get code;

  Timestamp get createdAt;

  InviteGuild? get guild;

  User? get inviter;

  int get maxAge;

  int get maxUses;

  bool get temporary;

  BigInt get uses;

  set channel(InviteChannel channel);

  set code(String code);

  set createdAt(Timestamp createdAt);

  set guild(InviteGuild? guild);

  set inviter(User? inviter);

  set maxAge(int maxAge);

  set maxUses(int maxUses);

  set temporary(bool temporary);

  set uses(BigInt uses);

  /// Returns a URL to use for the invite.
  ///
  /// # Examples
  ///
  /// Retrieve the URL for an invite with the code `WxZumR`:
  ///
  /// ```rust
  /// # use serenity::json::{json, from_value};
  /// # use serenity::model::prelude::*;
  /// #
  /// # fn main() {
  /// # let invite = from_value::<RichInvite>(json!({
  /// #     "code": "WxZumR",
  /// #     "channel": {
  /// #         "id": ChannelId::new(1),
  /// #         "name": "foo",
  /// #         "type": ChannelType::Text,
  /// #     },
  /// #     "created_at": "2017-01-29T15:35:17.136000+00:00",
  /// #     "guild": {
  /// #         "id": GuildId::new(2),
  /// #         "icon": None::<String>,
  /// #         "name": "baz",
  /// #         "splash_hash": None::<String>,
  /// #         "text_channel_count": None::<u64>,
  /// #         "voice_channel_count": None::<u64>,
  /// #         "features": ["NEWS", "DISCOVERABLE"],
  /// #         "verification_level": 2,
  /// #         "nsfw_level": 0,
  /// #     },
  /// #     "inviter": {
  /// #         "avatar": None::<String>,
  /// #         "bot": false,
  /// #         "discriminator": "1234",
  /// #         "id": UserId::new(4),
  /// #         "username": "qux",
  /// #         "public_flags": None::<UserPublicFlags>,
  /// #     },
  /// #     "max_age": 5,
  /// #     "max_uses": 6,
  /// #     "temporary": true,
  /// #     "uses": 7,
  /// # })).unwrap();
  /// #
  /// assert_eq!(invite.url(), "https://discord.gg/WxZumR");
  /// # }
  /// ```
  Future<String> url();
}

/// [Discord docs](https://discord.com/developers/docs/resources/invite#invite-stage-instance-object).
class InviteStageInstance {
  /// The members speaking in the Stage
  final List<PartialMember> members;

  /// The number of users in the Stage
  final BigInt participantCount;

  /// The number of users speaking in the Stage
  final BigInt speakerCount;

  /// The topic of the Stage instance (1-120 characters)
  final String topic;

  const InviteStageInstance({
    required this.members,
    required this.participantCount,
    required this.speakerCount,
    required this.topic,
  });

  @override
  int get hashCode =>
      members.hashCode ^
      participantCount.hashCode ^
      speakerCount.hashCode ^
      topic.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InviteStageInstance &&
          runtimeType == other.runtimeType &&
          members == other.members &&
          participantCount == other.participantCount &&
          speakerCount == other.speakerCount &&
          topic == other.topic;
}
