// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `cmp`, `eq`, `fmt`, `from`, `from`, `from`, `from`, `partial_cmp`

/// A utility struct to help with working with the basic representation of a colour.
///
/// This is particularly useful when working with a [`Role`]'s colour, as the API works with an
/// integer value instead of an RGB value.
///
/// Instances can be created by using the struct's associated functions. These produce presets
/// equivalent to those found in the official client's colour picker.
///
/// # Examples
///
/// Passing in a role's colour, and then retrieving its green component via [`Self::g`]:
///
/// ```rust
/// # use serenity::json::{json, from_value};
/// # use serenity::model::guild::Role;
/// # use serenity::model::id::RoleId;
/// # use serenity::model::id::GuildId;
/// # use serenity::model::permissions;
/// #
/// # fn main() {
/// # let role = from_value::<Role>(json!({
/// #     "color": Colour::BLURPLE,
/// #     "hoist": false,
/// #     "id": RoleId::new(1),
/// #     "guild_id": GuildId::new(2),
/// #     "managed": false,
/// #     "mentionable": false,
/// #     "name": "test",
/// #     "permissions": permissions::PRESET_GENERAL,
/// #     "position": 7,
/// # })).unwrap();
/// #
/// use serenity::model::Colour;
///
/// // assuming a `role` has already been bound
///
/// let green = role.colour.g();
///
/// println!("The green component is: {}", green);
/// # }
/// ```
///
/// Creating an instance with the [`Self::DARK_TEAL`] preset:
///
/// ```rust
/// use serenity::model::Colour;
///
/// let colour = Colour::DARK_TEAL;
///
/// assert_eq!(colour.tuple(), (17, 128, 106));
/// ```
///
/// Colours can also be directly compared for equivalence:
///
/// ```rust
/// use serenity::model::Colour;
///
/// let blitz_blue = Colour::BLITZ_BLUE;
/// let fooyoo = Colour::FOOYOO;
/// let fooyoo2 = Colour::FOOYOO;
/// assert!(blitz_blue != fooyoo);
/// assert_eq!(fooyoo, fooyoo2);
/// assert!(blitz_blue > fooyoo);
/// ```
///
/// [`Role`]: crate::model::guild::Role
class Colour {
  final int field0;

  const Colour({required this.field0});

  /// Returns the blue RGB component of this Colour.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// assert_eq!(Colour::new(6573123).b(), 67);
  /// ```
  Future<int> b() =>
      RustLib.instance.api.serenityModelColourColourB(that: this);

  static Future<Colour> default_() =>
      RustLib.instance.api.serenityModelColourColourDefault();

  /// Generates a new Colour from an RGB value, creating an inner u32 representation.
  ///
  /// # Examples
  ///
  /// Creating a [`Colour`] via its RGB values will set its inner u32 correctly:
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// assert!(Colour::from_rgb(255, 0, 0).0 == 0xFF0000);
  /// assert!(Colour::from_rgb(217, 23, 211).0 == 0xD917D3);
  /// ```
  ///
  /// And you can then retrieve those same RGB values via its methods:
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// let colour = Colour::from_rgb(217, 45, 215);
  ///
  /// assert_eq!(colour.r(), 217);
  /// assert_eq!(colour.g(), 45);
  /// assert_eq!(colour.b(), 215);
  /// assert_eq!(colour.tuple(), (217, 45, 215));
  /// ```
  static Future<Colour> fromRgb({
    required int red,
    required int green,
    required int blue,
  }) => RustLib.instance.api.serenityModelColourColourFromRgb(
    red: red,
    green: green,
    blue: blue,
  );

  /// Returns the green RGB component of this Colour.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// assert_eq!(Colour::new(6573123).g(), 76);
  /// ```
  Future<int> g() =>
      RustLib.instance.api.serenityModelColourColourG(that: this);

  /// Returns a hexadecimal string of this Colour.
  ///
  /// This is equivalent to passing the integer value through [`std::fmt::UpperHex`] with 0
  /// padding and 6 width.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// assert_eq!(Colour::new(6573123).hex(), "644C43");
  /// ```
  Future<String> hex() =>
      RustLib.instance.api.serenityModelColourColourHex(that: this);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Generates a new Colour with the given integer value set.
  ///
  /// # Examples
  ///
  /// Create a new Colour, and then ensure that its inner value is equivalent to a specific RGB
  /// value, retrieved via [`Self::tuple`]:
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// let colour = Colour::new(6573123);
  ///
  /// assert_eq!(colour.tuple(), (100, 76, 67));
  /// ```
  static Future<Colour> newInstance({required int value}) =>
      RustLib.instance.api.serenityModelColourColourNew(value: value);

  /// Returns the red RGB component of this Colour.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// assert_eq!(Colour::new(6573123).r(), 100);
  /// ```
  Future<int> r() =>
      RustLib.instance.api.serenityModelColourColourR(that: this);

  /// Returns a tuple of the red, green, and blue components of this Colour.
  ///
  /// This is equivalent to creating a tuple with the return values of [`Self::r`], [`Self::g`],
  /// and [`Self::b`].
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::model::Colour;
  ///
  /// assert_eq!(Colour::new(6573123).tuple(), (100, 76, 67));
  /// ```
  Future<(int, int, int)> tuple() =>
      RustLib.instance.api.serenityModelColourColourTuple(that: this);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Colour &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}
