// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import 'application/interaction.dart';
import 'channel.dart';
import 'id.dart';
import 'misc.dart';
import 'monetization.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'permissions.dart';
import 'user.dart';
part 'application.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ButtonStyle`, `ResolvedValue`, `Unresolved`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `bits`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `cmp`, `cmp`, `cmp`, `deserialize`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_bits_retain`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `partial_cmp`, `partial_cmp`, `partial_cmp`, `partial_cmp`, `serialize`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ActionRow>>
abstract class ActionRow implements RustOpaqueInterface {
  List<ActionRowComponent> get components;

  ComponentType get kind;

  set components(List<ActionRowComponent> components);

  set kind(ComponentType kind);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ActionRowComponent>>
abstract class ActionRowComponent implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApplicationFlags>>
abstract class ApplicationFlags implements RustOpaqueInterface {
  static Future<ApplicationFlags> default_() =>
      RustLib.instance.api.serenityModelApplicationApplicationFlagsDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AuthorizingIntegrationOwner>>
abstract class AuthorizingIntegrationOwner implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AutocompleteOption < 'static>>>
abstract class AutocompleteOption implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < MessageInteraction >>>
abstract class BoxMessageInteraction implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < MessageInteractionMetadata >>>
abstract class BoxMessageInteractionMetadata implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Button>>
abstract class Button implements RustOpaqueInterface {
  ButtonKind get data;

  bool get disabled;

  ReactionType? get emoji;

  ComponentType get kind;

  String? get label;

  set data(ButtonKind data);

  set disabled(bool disabled);

  set emoji(ReactionType? emoji);

  set kind(ComponentType kind);

  set label(String? label);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ButtonKind>>
abstract class ButtonKind implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Command>>
abstract class Command implements RustOpaqueInterface {
  ApplicationId get applicationId;

  List<InteractionContext>? get contexts;

  Permissions? get defaultMemberPermissions;

  String get description;

  Map<String, String>? get descriptionLocalizations;

  String? get descriptionLocalized;

  bool? get dmPermission;

  GuildId? get guildId;

  EntryPointHandlerType? get handler;

  CommandId get id;

  List<InstallationContext> get integrationTypes;

  CommandType get kind;

  String get name;

  Map<String, String>? get nameLocalizations;

  String? get nameLocalized;

  bool get nsfw;

  List<CommandOption> get options;

  CommandVersionId get version;

  set applicationId(ApplicationId applicationId);

  set contexts(List<InteractionContext>? contexts);

  set defaultMemberPermissions(Permissions? defaultMemberPermissions);

  set description(String description);

  set descriptionLocalizations(Map<String, String>? descriptionLocalizations);

  set descriptionLocalized(String? descriptionLocalized);

  set dmPermission(bool? dmPermission);

  set guildId(GuildId? guildId);

  set handler(EntryPointHandlerType? handler);

  set id(CommandId id);

  set integrationTypes(List<InstallationContext> integrationTypes);

  set kind(CommandType kind);

  set name(String name);

  set nameLocalizations(Map<String, String>? nameLocalizations);

  set nameLocalized(String? nameLocalized);

  set nsfw(bool nsfw);

  set options(List<CommandOption> options);

  set version(CommandVersionId version);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandData>>
abstract class CommandData implements RustOpaqueInterface {
  GuildId? get guildId;

  CommandId get id;

  CommandType get kind;

  String get name;

  List<CommandDataOption> get options;

  CommandDataResolved get resolved;

  TargetId? get targetId;

  set guildId(GuildId? guildId);

  set id(CommandId id);

  set kind(CommandType kind);

  set name(String name);

  set options(List<CommandDataOption> options);

  set resolved(CommandDataResolved resolved);

  set targetId(TargetId? targetId);

  /// Returns the autocomplete option from `CommandData::options`.
  Future<AutocompleteOption?> autocomplete();

  /// Returns the resolved options from `CommandData::options` and [`CommandData::resolved`].
  Future<List<ResolvedOption>> options();

  /// The target resolved data of [`target_id`]
  ///
  /// [`target_id`]: Self::target_id
  Future<ResolvedTarget?> target();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandDataOption>>
abstract class CommandDataOption implements RustOpaqueInterface {
  String get name;

  CommandDataOptionValue get value;

  set name(String name);

  set value(CommandDataOptionValue value);

  Future<CommandOptionType> kind();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandDataOptionValue>>
abstract class CommandDataOptionValue implements RustOpaqueInterface {
  /// If the value is an `AttachmentId`, returns the associated ID. Returns None otherwise.
  Future<AttachmentId?> asAttachmentId();

  /// If the value is a boolean, returns the associated f64. Returns None otherwise.
  Future<bool?> asBool();

  /// If the value is an `ChannelId`, returns the associated ID. Returns None otherwise.
  Future<ChannelId?> asChannelId();

  /// If the value is a number, returns the associated f64. Returns None otherwise.
  Future<double?> asF64();

  /// If the value is an integer, returns the associated f64. Returns None otherwise.
  Future<PlatformInt64?> asI64();

  /// If the value is an `GenericId`, returns the associated ID. Returns None otherwise.
  Future<GenericId?> asMentionable();

  /// If the value is an `RoleId`, returns the associated ID. Returns None otherwise.
  Future<RoleId?> asRoleId();

  /// If the value is a string, returns the associated str. Returns None otherwise.
  Future<Str?> asStr();

  /// If the value is an `UserId`, returns the associated ID. Returns None otherwise.
  Future<UserId?> asUserId();

  Future<CommandOptionType> kind();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandInteraction>>
abstract class CommandInteraction implements RustOpaqueInterface {
  Permissions? get appPermissions;

  ApplicationId get applicationId;

  AuthorizingIntegrationOwners get authorizingIntegrationOwners;

  PartialChannel? get channel;

  ChannelId get channelId;

  InteractionContext? get context;

  CommandData get data;

  List<Entitlement> get entitlements;

  GuildId? get guildId;

  String? get guildLocale;

  InteractionId get id;

  String get locale;

  BoxMember? get member;

  String get token;

  User get user;

  int get version;

  set appPermissions(Permissions? appPermissions);

  set applicationId(ApplicationId applicationId);

  set authorizingIntegrationOwners(
    AuthorizingIntegrationOwners authorizingIntegrationOwners,
  );

  set channel(PartialChannel? channel);

  set channelId(ChannelId channelId);

  set context(InteractionContext? context);

  set data(CommandData data);

  set entitlements(List<Entitlement> entitlements);

  set guildId(GuildId? guildId);

  set guildLocale(String? guildLocale);

  set id(InteractionId id);

  set locale(String locale);

  set member(BoxMember? member);

  set token(String token);

  set user(User user);

  set version(int version);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandOption>>
abstract class CommandOption implements RustOpaqueInterface {
  bool get autocomplete;

  List<ChannelType> get channelTypes;

  List<CommandOptionChoice> get choices;

  String get description;

  Map<String, String>? get descriptionLocalizations;

  CommandOptionType get kind;

  int? get maxLength;

  Number? get maxValue;

  int? get minLength;

  Number? get minValue;

  String get name;

  Map<String, String>? get nameLocalizations;

  List<CommandOption> get options;

  bool get required;

  set autocomplete(bool autocomplete);

  set channelTypes(List<ChannelType> channelTypes);

  set choices(List<CommandOptionChoice> choices);

  set description(String description);

  set descriptionLocalizations(Map<String, String>? descriptionLocalizations);

  set kind(CommandOptionType kind);

  set maxLength(int? maxLength);

  set maxValue(Number? maxValue);

  set minLength(int? minLength);

  set minValue(Number? minValue);

  set name(String name);

  set nameLocalizations(Map<String, String>? nameLocalizations);

  set options(List<CommandOption> options);

  set required(bool required_);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandOptionChoice>>
abstract class CommandOptionChoice implements RustOpaqueInterface {
  String get name;

  Map<String, String>? get nameLocalizations;

  Value get value;

  set name(String name);

  set nameLocalizations(Map<String, String>? nameLocalizations);

  set value(Value value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandOptionType>>
abstract class CommandOptionType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandPermission>>
abstract class CommandPermission implements RustOpaqueInterface {
  CommandPermissionId get id;

  CommandPermissionType get kind;

  bool get permission;

  set id(CommandPermissionId id);

  set kind(CommandPermissionType kind);

  set permission(bool permission);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandPermissionType>>
abstract class CommandPermissionType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandPermissions>>
abstract class CommandPermissions implements RustOpaqueInterface {
  ApplicationId get applicationId;

  GuildId get guildId;

  CommandId get id;

  List<CommandPermission> get permissions;

  set applicationId(ApplicationId applicationId);

  set guildId(GuildId guildId);

  set id(CommandId id);

  set permissions(List<CommandPermission> permissions);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandType>>
abstract class CommandType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ComponentInteraction>>
abstract class ComponentInteraction implements RustOpaqueInterface {
  Permissions? get appPermissions;

  ApplicationId get applicationId;

  AuthorizingIntegrationOwners get authorizingIntegrationOwners;

  PartialChannel? get channel;

  ChannelId get channelId;

  InteractionContext? get context;

  ComponentInteractionData get data;

  List<Entitlement> get entitlements;

  GuildId? get guildId;

  String? get guildLocale;

  InteractionId get id;

  String get locale;

  Member? get member;

  BoxMessage get message;

  String get token;

  User get user;

  int get version;

  set appPermissions(Permissions? appPermissions);

  set applicationId(ApplicationId applicationId);

  set authorizingIntegrationOwners(
    AuthorizingIntegrationOwners authorizingIntegrationOwners,
  );

  set channel(PartialChannel? channel);

  set channelId(ChannelId channelId);

  set context(InteractionContext? context);

  set data(ComponentInteractionData data);

  set entitlements(List<Entitlement> entitlements);

  set guildId(GuildId? guildId);

  set guildLocale(String? guildLocale);

  set id(InteractionId id);

  set locale(String locale);

  set member(Member? member);

  set message(BoxMessage message);

  set token(String token);

  set user(User user);

  set version(int version);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ComponentInteractionData>>
abstract class ComponentInteractionData implements RustOpaqueInterface {
  String get customId;

  ComponentInteractionDataKind get kind;

  set customId(String customId);

  set kind(ComponentInteractionDataKind kind);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ComponentInteractionDataKind>>
abstract class ComponentInteractionDataKind implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ComponentType>>
abstract class ComponentType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CurrentApplicationInfo>>
abstract class CurrentApplicationInfo implements RustOpaqueInterface {
  int? get approximateGuildCount;

  int? get approximateUserInstallCount;

  bool get botPublic;

  bool get botRequireCodeGrant;

  String? get coverImage;

  String? get customInstallUrl;

  String get description;

  ApplicationFlags? get flags;

  PartialGuild? get guild;

  GuildId? get guildId;

  ImageHash? get icon;

  ApplicationId get id;

  InstallParams? get installParams;

  Map<InstallationContext, InstallationContextConfig>
  get integrationTypesConfig;

  String? get interactionsEndpointUrl;

  String get name;

  User? get owner;

  SkuId? get primarySkuId;

  String? get privacyPolicyUrl;

  List<String>? get redirectUris;

  String? get roleConnectionsVerificationUrl;

  List<String> get rpcOrigins;

  String? get slug;

  List<String>? get tags;

  Team? get team;

  String? get termsOfServiceUrl;

  String get verifyKey;

  set approximateGuildCount(int? approximateGuildCount);

  set approximateUserInstallCount(int? approximateUserInstallCount);

  set botPublic(bool botPublic);

  set botRequireCodeGrant(bool botRequireCodeGrant);

  set coverImage(String? coverImage);

  set customInstallUrl(String? customInstallUrl);

  set description(String description);

  set flags(ApplicationFlags? flags);

  set guild(PartialGuild? guild);

  set guildId(GuildId? guildId);

  set icon(ImageHash? icon);

  set id(ApplicationId id);

  set installParams(InstallParams? installParams);

  set integrationTypesConfig(
    Map<InstallationContext, InstallationContextConfig> integrationTypesConfig,
  );

  set interactionsEndpointUrl(String? interactionsEndpointUrl);

  set name(String name);

  set owner(User? owner);

  set primarySkuId(SkuId? primarySkuId);

  set privacyPolicyUrl(String? privacyPolicyUrl);

  set redirectUris(List<String>? redirectUris);

  set roleConnectionsVerificationUrl(String? roleConnectionsVerificationUrl);

  set rpcOrigins(List<String> rpcOrigins);

  set slug(String? slug);

  set tags(List<String>? tags);

  set team(Team? team);

  set termsOfServiceUrl(String? termsOfServiceUrl);

  set verifyKey(String verifyKey);

  /// Returns the store url for the application. If included in a message, will render as a rich
  /// embed. See the [Discord docs] for details.
  ///
  /// [Discord docs]: https://discord.com/developers/docs/monetization/managing-your-store#linking-to-your-store
  Future<String> storeUrl();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntryPointHandlerType>>
abstract class EntryPointHandlerType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InputText>>
abstract class InputText implements RustOpaqueInterface {
  String get customId;

  ComponentType get kind;

  String? get label;

  int? get maxLength;

  int? get minLength;

  String? get placeholder;

  bool get required;

  InputTextStyle? get style;

  String? get value;

  set customId(String customId);

  set kind(ComponentType kind);

  set label(String? label);

  set maxLength(int? maxLength);

  set minLength(int? minLength);

  set placeholder(String? placeholder);

  set required(bool required_);

  set style(InputTextStyle? style);

  set value(String? value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InputTextStyle>>
abstract class InputTextStyle implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InstallParams>>
abstract class InstallParams implements RustOpaqueInterface {
  Permissions get permissions;

  List<Scope> get scopes;

  set permissions(Permissions permissions);

  set scopes(List<Scope> scopes);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InstallationContext>>
abstract class InstallationContext implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Interaction>>
abstract class Interaction implements RustOpaqueInterface {
  /// Permissions the app or bot has within the channel the interaction was sent from.
  Future<Permissions?> appPermissions();

  /// Gets the interaction application Id
  Future<ApplicationId> applicationId();

  /// Converts this to a [`CommandInteraction`]
  Future<CommandInteraction?> asAutocomplete();

  /// Converts this to an [`CommandInteraction`]
  Future<CommandInteraction?> asCommand();

  /// Converts this to a [`ComponentInteraction`]
  Future<ComponentInteraction?> asMessageComponent();

  /// Converts this to a [`ModalInteraction`]
  Future<ModalInteraction?> asModalSubmit();

  /// Converts this to a [`PingInteraction`]
  Future<PingInteraction?> asPing();

  /// Converts this to a [`CommandInteraction`]
  Future<CommandInteraction?> autocomplete();

  /// Converts this to an [`CommandInteraction`]
  Future<CommandInteraction?> command();

  /// For monetized applications, gets the invoking user's granted entitlements.
  Future<Entitlement?> entitlements();

  /// Guild ID the interaction was sent from, if any.
  Future<GuildId?> guildId();

  /// Gets the invoked guild locale.
  Future<Str?> guildLocale();

  /// Gets the interaction Id.
  Future<InteractionId> id();

  /// Converts this to a [`CommandInteraction`]
  Future<CommandInteraction?> intoAutocomplete();

  /// Converts this to an [`CommandInteraction`]
  Future<CommandInteraction?> intoCommand();

  /// Converts this to a [`ComponentInteraction`]
  Future<ComponentInteraction?> intoMessageComponent();

  /// Converts this to a [`ModalInteraction`]
  Future<ModalInteraction?> intoModalSubmit();

  /// Converts this to a [`PingInteraction`]
  Future<PingInteraction?> intoPing();

  /// Gets the interaction type
  Future<InteractionType> kind();

  /// Converts this to a [`ComponentInteraction`]
  Future<ComponentInteraction?> messageComponent();

  /// Converts this to a [`ModalInteraction`]
  Future<ModalInteraction?> modalSubmit();

  /// Converts this to a [`PingInteraction`]
  Future<PingInteraction?> ping();

  /// Gets the interaction token.
  Future<void> token();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InteractionContext>>
abstract class InteractionContext implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InteractionResponseFlags>>
abstract class InteractionResponseFlags implements RustOpaqueInterface {
  static Future<InteractionResponseFlags> default_() =>
      RustLib.instance.api
          .serenityModelApplicationInteractionResponseFlagsDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InteractionType>>
abstract class InteractionType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MembershipState>>
abstract class MembershipState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageCommandInteractionMetadata>>
abstract class MessageCommandInteractionMetadata
    implements RustOpaqueInterface {
  AuthorizingIntegrationOwners get authorizingIntegrationOwners;

  InteractionId get id;

  MessageId? get originalResponseMessageId;

  MessageId? get targetMessageId;

  User? get targetUser;

  User get user;

  set authorizingIntegrationOwners(
    AuthorizingIntegrationOwners authorizingIntegrationOwners,
  );

  set id(InteractionId id);

  set originalResponseMessageId(MessageId? originalResponseMessageId);

  set targetMessageId(MessageId? targetMessageId);

  set targetUser(User? targetUser);

  set user(User user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageComponentInteractionMetadata>>
abstract class MessageComponentInteractionMetadata
    implements RustOpaqueInterface {
  AuthorizingIntegrationOwners get authorizingIntegrationOwners;

  InteractionId get id;

  MessageId get interactedMessageId;

  MessageId? get originalResponseMessageId;

  User get user;

  set authorizingIntegrationOwners(
    AuthorizingIntegrationOwners authorizingIntegrationOwners,
  );

  set id(InteractionId id);

  set interactedMessageId(MessageId interactedMessageId);

  set originalResponseMessageId(MessageId? originalResponseMessageId);

  set user(User user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageInteraction>>
abstract class MessageInteraction implements RustOpaqueInterface {
  InteractionId get id;

  InteractionType get kind;

  PartialMember? get member;

  String get name;

  User get user;

  set id(InteractionId id);

  set kind(InteractionType kind);

  set member(PartialMember? member);

  set name(String name);

  set user(User user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageModalSubmitInteractionMetadata>>
abstract class MessageModalSubmitInteractionMetadata
    implements RustOpaqueInterface {
  AuthorizingIntegrationOwners get authorizingIntegrationOwners;

  InteractionId get id;

  MessageId? get originalResponseMessageId;

  MessageInteractionMetadata get triggeringInteractionMetadata;

  User get user;

  set authorizingIntegrationOwners(
    AuthorizingIntegrationOwners authorizingIntegrationOwners,
  );

  set id(InteractionId id);

  set originalResponseMessageId(MessageId? originalResponseMessageId);

  set triggeringInteractionMetadata(
    MessageInteractionMetadata triggeringInteractionMetadata,
  );

  set user(User user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ModalInteraction>>
abstract class ModalInteraction implements RustOpaqueInterface {
  Permissions? get appPermissions;

  ApplicationId get applicationId;

  PartialChannel? get channel;

  ChannelId get channelId;

  ModalInteractionData get data;

  List<Entitlement> get entitlements;

  GuildId? get guildId;

  String? get guildLocale;

  InteractionId get id;

  String get locale;

  Member? get member;

  BoxMessage? get message;

  String get token;

  User get user;

  int get version;

  set appPermissions(Permissions? appPermissions);

  set applicationId(ApplicationId applicationId);

  set channel(PartialChannel? channel);

  set channelId(ChannelId channelId);

  set data(ModalInteractionData data);

  set entitlements(List<Entitlement> entitlements);

  set guildId(GuildId? guildId);

  set guildLocale(String? guildLocale);

  set id(InteractionId id);

  set locale(String locale);

  set member(Member? member);

  set message(BoxMessage? message);

  set token(String token);

  set user(User user);

  set version(int version);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Number>>
abstract class Number implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PartialCurrentApplicationInfo>>
abstract class PartialCurrentApplicationInfo implements RustOpaqueInterface {
  ApplicationFlags get flags;

  ApplicationId get id;

  set flags(ApplicationFlags flags);

  set id(ApplicationId id);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PingInteraction>>
abstract class PingInteraction implements RustOpaqueInterface {
  ApplicationId get applicationId;

  InteractionId get id;

  String get token;

  int get version;

  set applicationId(ApplicationId applicationId);

  set id(InteractionId id);

  set token(String token);

  set version(int version);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResolvedOption < 'static>>>
abstract class ResolvedOption implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResolvedTarget < 'static>>>
abstract class ResolvedTarget implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SelectMenu>>
abstract class SelectMenu implements RustOpaqueInterface {
  List<ChannelType> get channelTypes;

  String? get customId;

  bool get disabled;

  ComponentType get kind;

  int? get maxValues;

  int? get minValues;

  List<SelectMenuOption> get options;

  String? get placeholder;

  set channelTypes(List<ChannelType> channelTypes);

  set customId(String? customId);

  set disabled(bool disabled);

  set kind(ComponentType kind);

  set maxValues(int? maxValues);

  set minValues(int? minValues);

  set options(List<SelectMenuOption> options);

  set placeholder(String? placeholder);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Team>>
abstract class Team implements RustOpaqueInterface {
  ImageHash? get icon;

  GenericId get id;

  List<TeamMember> get members;

  String get name;

  UserId get ownerUserId;

  set icon(ImageHash? icon);

  set id(GenericId id);

  set members(List<TeamMember> members);

  set name(String name);

  set ownerUserId(UserId ownerUserId);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TeamMember>>
abstract class TeamMember implements RustOpaqueInterface {
  MembershipState get membershipState;

  List<String> get permissions;

  TeamMemberRole get role;

  GenericId get teamId;

  User get user;

  set membershipState(MembershipState membershipState);

  set permissions(List<String> permissions);

  set role(TeamMemberRole role);

  set teamId(GenericId teamId);

  set user(User user);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TeamMemberRole>>
abstract class TeamMemberRole implements RustOpaqueInterface {}

class AuthorizingIntegrationOwners {
  final List<AuthorizingIntegrationOwner> field0;

  const AuthorizingIntegrationOwners({required this.field0});

  static Future<AuthorizingIntegrationOwners> default_() =>
      RustLib.instance.api
          .serenityModelApplicationAuthorizingIntegrationOwnersDefault();

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuthorizingIntegrationOwners &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// The resolved data of a command data interaction payload. It contains the objects of
/// [`CommandDataOption`]s.
///
/// [Discord docs](https://discord.com/developers/docs/interactions/receiving-and-responding#interaction-object-resolved-data-structure).
class CommandDataResolved {
  /// The resolved users.
  final Map<UserId, User> users;

  /// The resolved partial members.
  final Map<UserId, PartialMember> members;

  /// The resolved roles.
  final Map<RoleId, Role> roles;

  /// The resolved partial channels.
  final Map<ChannelId, PartialChannel> channels;

  /// The resolved messages.
  final Map<MessageId, Message> messages;

  /// The resolved attachments.
  final Map<AttachmentId, Attachment> attachments;

  const CommandDataResolved({
    required this.users,
    required this.members,
    required this.roles,
    required this.channels,
    required this.messages,
    required this.attachments,
  });

  static Future<CommandDataResolved> default_() =>
      RustLib.instance.api.serenityModelApplicationCommandDataResolvedDefault();

  @override
  int get hashCode =>
      users.hashCode ^
      members.hashCode ^
      roles.hashCode ^
      channels.hashCode ^
      messages.hashCode ^
      attachments.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CommandDataResolved &&
          runtimeType == other.runtimeType &&
          users == other.users &&
          members == other.members &&
          roles == other.roles &&
          channels == other.channels &&
          messages == other.messages &&
          attachments == other.attachments;
}

/// Information about how the [`CurrentApplicationInfo`] is installed.
///
/// [Discord docs](https://discord.com/developers/docs/resources/application#application-object-application-integration-types).
class InstallationContextConfig {
  final InstallParams? oauth2InstallParams;

  const InstallationContextConfig({this.oauth2InstallParams});

  @override
  int get hashCode => oauth2InstallParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InstallationContextConfig &&
          runtimeType == other.runtimeType &&
          oauth2InstallParams == other.oauth2InstallParams;
}

@freezed
sealed class MessageInteractionMetadata with _$MessageInteractionMetadata {
  const MessageInteractionMetadata._();

  const factory MessageInteractionMetadata.command(
    MessageCommandInteractionMetadata field0,
  ) = MessageInteractionMetadata_Command;
  const factory MessageInteractionMetadata.component(
    MessageComponentInteractionMetadata field0,
  ) = MessageInteractionMetadata_Component;
  const factory MessageInteractionMetadata.modalSubmit(
    MessageModalSubmitInteractionMetadata field0,
  ) = MessageInteractionMetadata_ModalSubmit;
  const factory MessageInteractionMetadata.unknown(InteractionType field0) =
      MessageInteractionMetadata_Unknown;
}

/// A modal submit interaction data, provided by [`ModalInteraction::data`]
///
/// [Discord docs](https://discord.com/developers/docs/interactions/receiving-and-responding#interaction-object-interaction-data-structure).
class ModalInteractionData {
  /// The custom id of the modal
  final String customId;

  /// The components.
  final List<ActionRow> components;

  const ModalInteractionData({
    required this.customId,
    required this.components,
  });

  @override
  int get hashCode => customId.hashCode ^ components.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModalInteractionData &&
          runtimeType == other.runtimeType &&
          customId == other.customId &&
          components == other.components;
}

/// The available OAuth2 Scopes.
///
/// [Discord docs](https://discord.com/developers/docs/topics/oauth2#shared-resources-oauth2-scopes).
enum Scope {
  /// For oauth2 bots, this puts the bot in the user's selected guild by default.
  bot,

  /// Allows your app to use Slash Commands in a guild.
  applicationsCommands,

  /// Allows your app to update its Slash Commands via this bearer token - client credentials
  /// grant only.
  applicationsCommandsUpdate,

  /// Allows your app to update permissions for its commands in a guild a user has permissions
  /// to.
  applicationsCommandsPermissionsUpdate,

  /// Allows `/users/@me` without [`Self::Email`].
  identify,

  /// Enables `/users/@me` to return an `email` field.
  email,

  /// Allows `/users/@me/connections` to return linked third-party accounts.
  connections,

  /// Allows `/users/@me/guilds` to return basic information about all of a user's guilds.
  guilds,

  /// Allows `/guilds/{guild.id}/members/{user.id}` to be used for joining users to a guild.
  guildsJoin,

  /// Allows `/users/@me/guilds/{guild.id}/member` to return a user's member information in a
  /// guild.
  guildsMembersRead,

  /// Allows your app to join users to a group dm.
  gdmJoin,

  /// For local rpc server access, this allows you to control a user's local Discord client -
  /// requires Discord approval.
  rpc,

  /// For local rpc server api access, this allows you to receive notifications pushed out to the
  /// user - requires Discord approval.
  rpcNotificationsRead,
  rpcVoiceRead,
  rpcVoiceWrite,
  rpcActivitiesWrite,

  /// This generates a webhook that is returned in the oauth token response for authorization
  /// code grants.
  webhookIncoming,

  /// For local rpc server api access, this allows you to read messages from all client channels
  /// (otherwise restricted to channels/guilds your app creates).
  messagesRead,

  /// Allows your app to upload/update builds for a user's applications - requires Discord
  /// approval.
  applicationsBuildsUpload,

  /// Allows your app to read build data for a user's applications.
  applicationsBuildsRead,

  /// Allows your app to read and update store data (SKUs, store listings, achievements, etc.)
  /// for a user's applications.
  applicationsStoreUpdate,

  /// Allows your app to read entitlements for a user's applications.
  applicationsEntitlements,

  /// Allows your app to fetch data from a user's "Now Playing/Recently Played" list - requires
  /// Discord approval.
  activitiesRead,

  /// Allows your app to update a user's activity - requires Discord approval (Not required for
  /// gamesdk activity manager!).
  activitiesWrite,

  /// Allows your app to know a user's friends and implicit relationships - requires Discord
  /// approval.
  relationshipsRead,

  /// Allows your app to see information about the user's DMs and group DMs - requires Discord
  /// approval.
  dmChannelsRead,

  /// Allows your app to connect to voice on user's behalf and see all the voice members -
  /// requires Discord approval.
  voice,

  /// Allows your app to update a user's connection and metadata for the app.
  roleConnectionsWrite,
}

/// A select menu component options.
///
/// [Discord docs](https://discord.com/developers/docs/interactions/message-components#select-menu-object-select-option-structure).
class SelectMenuOption {
  /// The text displayed on this option.
  final String label;

  /// The value to be sent for this option.
  final String value;

  /// The description shown for this option.
  final String? description;

  /// The emoji displayed on this option.
  final ReactionType? emoji;

  /// Render this option as the default selection.
  final bool default_;

  const SelectMenuOption({
    required this.label,
    required this.value,
    this.description,
    this.emoji,
    required this.default_,
  });

  @override
  int get hashCode =>
      label.hashCode ^
      value.hashCode ^
      description.hashCode ^
      emoji.hashCode ^
      default_.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SelectMenuOption &&
          runtimeType == other.runtimeType &&
          label == other.label &&
          value == other.value &&
          description == other.description &&
          emoji == other.emoji &&
          default_ == other.default_;
}
