// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../utils.dart';
import 'colour.dart';
import 'id.dart';
import 'mention.dart';
import 'misc.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'timestamp.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `bits`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `cmp`, `deref_mut`, `deref`, `deserialize`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_bits_retain`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `partial_cmp`, `partial_cmp`, `serialize`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `create_dm_channel`, `create_dm_channel`, `direct_message`, `direct_message`, `dm`, `dm`, `edit`, `has_role`, `nick_in`, `refresh`, `to_user_cached`, `to_user`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CurrentUser>>
abstract class CurrentUser implements RustOpaqueInterface, Mentionable {
  static Future<CurrentUser> default_() =>
      RustLib.instance.api.serenityModelUserCurrentUserDefault();

  @override
  Future<Mention> mention();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PremiumType>>
abstract class PremiumType implements RustOpaqueInterface {
  static Future<PremiumType> default_() =>
      RustLib.instance.api.serenityModelUserPremiumTypeDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<User>>
abstract class User
    implements RustOpaqueInterface, ArgumentConvert, Mentionable {
  Colour? get accentColour;

  ImageHash? get avatar;

  ImageHash? get banner;

  bool get bot;

  NonZeroU16? get discriminator;

  String? get email;

  UserPublicFlags get flags;

  String? get globalName;

  UserId get id;

  String? get locale;

  BoxPartialMember? get member;

  bool get mfaEnabled;

  String get name;

  PremiumType get premiumType;

  UserPublicFlags? get publicFlags;

  bool get system;

  bool? get verified;

  set accentColour(Colour? accentColour);

  set avatar(ImageHash? avatar);

  set banner(ImageHash? banner);

  set bot(bool bot);

  set discriminator(NonZeroU16? discriminator);

  set email(String? email);

  set flags(UserPublicFlags flags);

  set globalName(String? globalName);

  set id(UserId id);

  set locale(String? locale);

  set member(BoxPartialMember? member);

  set mfaEnabled(bool mfaEnabled);

  set name(String name);

  set premiumType(PremiumType premiumType);

  set publicFlags(UserPublicFlags? publicFlags);

  set system(bool system);

  set verified(bool? verified);

  /// Returns the formatted URL of the user's icon, if one exists.
  ///
  /// This will produce a WEBP image URL, or GIF if the user has a GIF avatar.
  Future<String?> avatarUrl();

  /// Returns the formatted URL of the user's banner, if one exists.
  ///
  /// This will produce a WEBP image URL, or GIF if the user has a GIF banner.
  ///
  /// **Note**: This will only be present if the user is fetched via Rest API, e.g. with
  /// [`crate::http::Http::get_user`].
  Future<String?> bannerUrl();

  /// Retrieves the time that this user was created at.
  Future<Timestamp> createdAt();

  static Future<User> default_() =>
      RustLib.instance.api.serenityModelUserUserDefault();

  /// Returns the formatted URL to the user's default avatar URL.
  ///
  /// This will produce a PNG URL.
  Future<String> defaultAvatarUrl();

  /// Calculates the user's display name.
  ///
  /// The global name takes priority over the user's username if it exists.
  ///
  /// Note: Guild specific information is not included as this is only available on the [Member].
  Future<void> displayName();

  /// Retrieves the URL to the user's avatar, falling back to the default avatar if needed.
  ///
  /// This will call [`Self::avatar_url`] first, and if that returns [`None`], it then falls back
  /// to [`Self::default_avatar_url`].
  Future<String> face();

  @override
  Future<Mention> mention();

  /// Returns a static formatted URL of the user's icon, if one exists.
  ///
  /// This will always produce a WEBP image URL.
  Future<String?> staticAvatarUrl();

  /// Retrieves the URL to the static version of the user's avatar, falling back to the default
  /// avatar if needed.
  ///
  /// This will call [`Self::static_avatar_url`] first, and if that returns [`None`], it then
  /// falls back to [`Self::default_avatar_url`].
  Future<String> staticFace();

  /// Returns the "tag" for the user.
  ///
  /// The "tag" is defined as "username#discriminator", such as "zeyla#5479".
  ///
  /// # Examples
  ///
  /// Make a command to tell the user what their tag is:
  ///
  /// ```rust,no_run
  /// # use serenity::prelude::*;
  /// # use serenity::model::prelude::*;
  /// # struct Handler;
  ///
  /// #[serenity::async_trait]
  /// # #[cfg(feature = "client")]
  /// impl EventHandler for Handler {
  ///     async fn message(&self, context: Context, msg: Message) {
  ///         if msg.content == "!mytag" {
  ///             let content = format!("Your tag is: {}", msg.author.tag());
  ///             let _ = msg.channel_id.say(&context.http, &content).await;
  ///         }
  ///     }
  /// }
  /// ```
  Future<String> tag();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserPublicFlags>>
abstract class UserPublicFlags implements RustOpaqueInterface {
  static Future<UserPublicFlags> default_() =>
      RustLib.instance.api.serenityModelUserUserPublicFlagsDefault();
}

/// The representation of a user's status.
///
/// [Discord docs](https://discord.com/developers/docs/topics/gateway-events#update-presence-status-types).
enum OnlineStatus {
  doNotDisturb,
  idle,
  invisible,
  offline,
  online;

  static Future<OnlineStatus> default_() =>
      RustLib.instance.api.serenityModelUserOnlineStatusDefault();

  Future<void> name() =>
      RustLib.instance.api.serenityModelUserOnlineStatusName(that: this);
}
