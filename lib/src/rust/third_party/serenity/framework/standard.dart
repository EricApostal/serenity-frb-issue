// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../framework.dart';
import '../model/application.dart';
import '../model/colour.dart';
import '../model/permissions.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `dispatch`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `DispatchError`, `Iter`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `allowed_roles`, `allowed_roles`, `checks`, `checks`, `help_available`, `help_available`, `only_in`, `only_in`, `owner_privilege`, `owner_privilege`, `owners_only`, `owners_only`, `required_permissions`, `required_permissions`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `after`, `before`, `bucket`, `group`, `help`, `normal_message`, `on_dispatch_error`, `prefix_only`, `unrecognised_command`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Args>>
abstract class Args implements RustOpaqueInterface {
  /// Move to the next argument. This increments the offset pointer.
  ///
  /// Does nothing if the message is empty.
  Future<void> advance();

  /// Retrieve the current argument.
  ///
  /// Applies modifications set by [`Self::trimmed`] and [`Self::quoted`].
  ///
  /// # Note
  ///
  /// This borrows [`Args`] for the entire lifetime of the returned argument.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::framework::standard::{Args, Delimiter};
  ///
  /// let mut args = Args::new("4 2", &[Delimiter::Single(' ')]);
  ///
  /// assert_eq!(args.current(), Some("4"));
  /// args.advance();
  /// assert_eq!(args.current(), Some("2"));
  /// args.advance();
  /// assert_eq!(args.current(), None);
  /// ```
  Future<Str?> current();

  /// Assert that there are no more arguments left.
  Future<bool> isEmpty();

  /// Return the full amount of recognised arguments. The length of the "arguments queue".
  ///
  /// # Note
  ///
  /// The value returned is to be assumed to stay static. However, if [`Self::find`] was called
  /// previously, and was successful, then the value is subtracted by one.
  Future<BigInt> len();

  /// Get the original, unmodified message passed to the command.
  Future<void> message();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new instance of [`Args`] for parsing arguments.
  ///
  /// For more reference, look at [`Args`]'s struct documentation.
  ///
  /// # Example
  ///
  /// ```rust
  /// use serenity::framework::standard::{Args, Delimiter};
  ///
  /// let mut args = Args::new(
  /// // Our message from which we'll parse over.
  /// "the quick brown fox jumps over the lazy",
  ///
  /// // The "delimiters", or aka the separators. They denote how we distinguish arguments as their own.
  /// // For this example, we'll use one delimiter, the space (`0x20`), which will separate the message.
  /// &[Delimiter::Single(' ')],
  /// );
  ///
  /// assert_eq!(args.single::<String>().unwrap(), "the");
  /// assert_eq!(args.single::<String>().unwrap(), "quick");
  /// assert_eq!(args.single::<String>().unwrap(), "brown");
  ///
  /// // We shall not see `the quick brown` again.
  /// assert_eq!(args.rest(), "fox jumps over the lazy");
  /// ```
  static Future<Args> newInstance({
    required String message,
    required List<Delimiter> possibleDelimiters,
  }) => RustLib.instance.api.serenityFrameworkStandardArgsNew(
    message: message,
    possibleDelimiters: possibleDelimiters,
  );

  /// Remove quotations surrounding all arguments.
  ///
  /// Note that only the quotes of the argument are taken into account. The quotes in the message
  /// are preserved.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::framework::standard::Args;
  ///
  /// let mut args = Args::new("\"42\"", &[]);
  ///
  /// // `quoted` lasts the whole lifetime of `Args`
  /// args.quoted();
  /// assert_eq!(args.current(), Some("42"));
  /// // or until we decide
  /// args.unquoted();
  /// assert_eq!(args.current(), Some("\"42\""));
  /// assert_eq!(args.message(), "\"42\"");
  /// ```
  Future<void> quoted();

  /// Return an iterator over all unmodified arguments.
  ///
  /// # Examples
  ///
  /// Join the arguments by a comma and a space.
  ///
  /// ```rust
  /// use serenity::framework::standard::{Args, Delimiter};
  ///
  /// let args = Args::new("Harry Hermione Ronald", &[Delimiter::Single(' ')]);
  ///
  /// let protagonists = args.raw().collect::<Vec<&str>>().join(", ");
  ///
  /// assert_eq!(protagonists, "Harry, Hermione, Ronald");
  /// ```
  Future<RawArguments> raw();

  /// Return an iterator over all arguments, stripped of their quotations if any were present.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::framework::standard::{Args, Delimiter};
  ///
  /// let args = Args::new("Saw \"The Mist\" \"A Quiet Place\"", &[Delimiter::Single(' ')]);
  ///
  /// let horror_movies = args.raw_quoted().collect::<Vec<&str>>();
  ///
  /// assert_eq!(&*horror_movies, &["Saw", "The Mist", "A Quiet Place"]);
  /// ```
  Future<RawArguments> rawQuoted();

  /// Return the amount of arguments still available.
  Future<BigInt> remaining();

  /// Starting from the offset, return the remainder of available arguments.
  ///
  /// Returns [`None`] if there are no remaining arguments.
  Future<Str?> remains();

  /// Starting from the offset, return the remainder of available arguments.
  Future<void> rest();

  /// Go back to the starting point.
  Future<void> restore();

  /// Go one step behind. This decrements the offset pointer.
  ///
  /// Does nothing if the offset pointer is `0`.
  Future<void> rewind();

  /// Apply trimming of whitespace to all arguments.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use serenity::framework::standard::Args;
  ///
  /// let mut args = Args::new("     42     ", &[]);
  ///
  /// // trimmed lasts for the whole lifetime of `Args`
  /// args.trimmed();
  /// assert_eq!(args.current(), Some("42"));
  /// // or until we decide ourselves
  /// args.untrimmed();
  /// assert_eq!(args.current(), Some("     42     "));
  /// assert_eq!(args.message(), "     42     ");
  /// ```
  Future<void> trimmed();

  /// Stop removing quotations of all arguments.
  ///
  /// # Examples
  ///
  /// Refer to [`Self::quoted`]'s examples.
  Future<void> unquoted();

  /// Halt trimming of whitespace to all arguments.
  ///
  /// # Examples
  ///
  /// Refer to [`Self::trimmed`]'s examples.
  Future<void> untrimmed();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandGroup>>
abstract class CommandGroup implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CommandOptions>>
abstract class CommandOptions implements RustOpaqueInterface {
  Str? get bucket;

  Str? get desc;

  bool get helpAvailable;

  int? get maxArgs;

  int? get minArgs;

  OnlyIn get onlyIn;

  bool get ownerPrivilege;

  bool get ownersOnly;

  Permissions get requiredPermissions;

  Str? get usage;

  set bucket(Str? bucket);

  set desc(Str? desc);

  set helpAvailable(bool helpAvailable);

  set maxArgs(int? maxArgs);

  set minArgs(int? minArgs);

  set onlyIn(OnlyIn onlyIn);

  set ownerPrivilege(bool ownerPrivilege);

  set ownersOnly(bool ownersOnly);

  set requiredPermissions(Permissions requiredPermissions);

  set usage(Str? usage);

  static Future<CommandOptions> default_() =>
      RustLib.instance.api.serenityFrameworkStandardCommandOptionsDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Configuration>>
abstract class Configuration implements RustOpaqueInterface {
  /// Builds a default framework configuration, setting the following:
  ///
  /// - **allow_dm** to `true`
  /// - **with_whitespace** to `(false, true, true)`
  /// - **by_space** to `true`
  /// - **blocked_guilds** to an empty HashSet
  /// - **blocked_users** to an empty HashSet,
  /// - **allowed_channels** to an empty HashSet,
  /// - **case_insensitive** to `false`
  /// - **delimiters** to `vec![' ']`
  /// - **disabled_commands** to an empty HashSet
  /// - **dynamic_prefixes** to an empty vector
  /// - **ignore_bots** to `true`
  /// - **ignore_webhooks** to `true`
  /// - **no_dm_prefix** to `false`
  /// - **on_mention** to `false`
  /// - **owners** to an empty HashSet
  /// - **prefix** to "~"
  static Future<Configuration> default_() =>
      RustLib.instance.api.serenityFrameworkStandardConfigurationDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Alias for Configuration::default
  static Future<Configuration> newInstance() =>
      RustLib.instance.api.serenityFrameworkStandardConfigurationNew();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Delimiter>>
abstract class Delimiter implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GroupOptions>>
abstract class GroupOptions implements RustOpaqueInterface {
  Command? get defaultCommand;

  Str? get description;

  bool get helpAvailable;

  OnlyIn get onlyIn;

  bool get ownerPrivilege;

  bool get ownersOnly;

  Permissions get requiredPermissions;

  Str? get summary;

  set defaultCommand(Command? defaultCommand);

  set description(Str? description);

  set helpAvailable(bool helpAvailable);

  set onlyIn(OnlyIn onlyIn);

  set ownerPrivilege(bool ownerPrivilege);

  set ownersOnly(bool ownersOnly);

  set requiredPermissions(Permissions requiredPermissions);

  set summary(Str? summary);

  static Future<GroupOptions> default_() =>
      RustLib.instance.api.serenityFrameworkStandardGroupOptionsDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HelpCommand>>
abstract class HelpCommand implements RustOpaqueInterface {
  ForFutFnFutContextFutMessageArgsFutHelpOptionsFutCommandGroupHashSetUserIdBoxFutureFutCommandResult
  get fun;

  set fun(
    ForFutFnFutContextFutMessageArgsFutHelpOptionsFutCommandGroupHashSetUserIdBoxFutureFutCommandResult
    fun,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HelpOptions>>
abstract class HelpOptions implements RustOpaqueInterface {
  Colour get embedErrorColour;

  Colour get embedSuccessColour;

  HelpBehaviour get lackingConditions;

  HelpBehaviour get lackingOwnership;

  HelpBehaviour get lackingPermissions;

  HelpBehaviour get lackingRole;

  BigInt get maxLevenshteinDistance;

  Str? get strikethroughCommandsTipInDm;

  Str? get strikethroughCommandsTipInGuild;

  HelpBehaviour get wrongChannel;

  set embedErrorColour(Colour embedErrorColour);

  set embedSuccessColour(Colour embedSuccessColour);

  set lackingConditions(HelpBehaviour lackingConditions);

  set lackingOwnership(HelpBehaviour lackingOwnership);

  set lackingPermissions(HelpBehaviour lackingPermissions);

  set lackingRole(HelpBehaviour lackingRole);

  set maxLevenshteinDistance(BigInt maxLevenshteinDistance);

  set strikethroughCommandsTipInDm(Str? strikethroughCommandsTipInDm);

  set strikethroughCommandsTipInGuild(Str? strikethroughCommandsTipInGuild);

  set wrongChannel(HelpBehaviour wrongChannel);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RawArguments < 'static>>>
abstract class RawArguments implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StandardFramework>>
abstract class StandardFramework implements RustOpaqueInterface, Framework {
  bool get initialized;

  set initialized(bool initialized);

  /// Configures the framework, setting non-default values.
  ///
  /// This passes a mutable reference to the current configuration, allowing for runtime
  /// configuration of the Framework.
  ///
  /// # Examples
  ///
  /// Configuring the framework for a [`Client`], [allowing whitespace between prefixes], and
  /// setting the [`prefix`] to `"~"`:
  ///
  /// ```rust,no_run
  /// # use serenity::prelude::*;
  /// # struct Handler;
  /// # impl EventHandler for Handler {}
  /// use serenity::framework::standard::{Configuration, StandardFramework};
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn std::error::Error>> {
  /// let framework = StandardFramework::new();
  /// framework.configure(Configuration::new().with_whitespace(true).prefix("~"));
  ///
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default())
  ///     .event_handler(Handler)
  ///     .framework(framework)
  ///     .await?;
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// [`Client`]: crate::Client
  /// [`prefix`]: Configuration::prefix
  /// [allowing whitespace between prefixes]: Configuration::with_whitespace
  Future<void> configure({required Configuration config});

  static Future<StandardFramework> default_() =>
      RustLib.instance.api.serenityFrameworkStandardStandardFrameworkDefault();

  /// Adds a group to be used by the framework. Primary use-case is runtime modification of
  /// groups in the framework; will _not_ mark the framework as initialized. Refer to
  /// [`Self::group`] for adding groups in initial configuration.
  ///
  /// Note: does _not_ return [`Self`] like many other commands. This is because it's not
  /// intended to be chained as the other commands are.
  Future<void> groupAdd({required CommandGroup group});

  /// Removes a group from being used in the framework. Primary use-case is runtime modification
  /// of groups in the framework.
  ///
  /// Note: does _not_ return [`Self`] like many other commands. This is because it's not
  /// intended to be chained as the other commands are.
  Future<void> groupRemove({required CommandGroup group});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<StandardFramework> newInstance() =>
      RustLib.instance.api.serenityFrameworkStandardStandardFrameworkNew();
}

abstract class CommonOptions {
  Future<void> allowedRoles();

  Future<void> checks();

  Future<bool> helpAvailable();

  Future<OnlyIn> onlyIn();

  Future<bool> ownerPrivilege();

  Future<bool> ownersOnly();

  Future<void> requiredPermissions();
}

/// Describes the behaviour the help-command shall execute once it encounters a command which the
/// user or command fails to meet following criteria :
/// - Lacking required permissions to execute the command.
/// - Lacking required roles to execute the command.
/// - The command can't be used in the current channel (as in `DM only` or `guild only`).
enum HelpBehaviour {
  /// The command will be displayed, hence nothing will be done.
  nothing,

  /// Strikes a command by applying `~~{command_name}~~`.
  strike,

  /// Does not list a command in the help-menu.
  hide_,
}

enum OnlyIn {
  dm,
  guild,
  none;

  static Future<OnlyIn> default_() =>
      RustLib.instance.api.serenityFrameworkStandardOnlyInDefault();
}

/// A configuration struct for deciding whether the framework should allow optional whitespace
/// between prefixes, group prefixes and command names.
class WithWhiteSpace {
  final bool prefixes;
  final bool groups;
  final bool commands;

  const WithWhiteSpace({
    required this.prefixes,
    required this.groups,
    required this.commands,
  });

  /// Impose the default settings to (false, true, true).
  static Future<WithWhiteSpace> default_() =>
      RustLib.instance.api.serenityFrameworkStandardWithWhiteSpaceDefault();

  @override
  int get hashCode => prefixes.hashCode ^ groups.hashCode ^ commands.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WithWhiteSpace &&
          runtimeType == other.runtimeType &&
          prefixes == other.prefixes &&
          groups == other.groups &&
          commands == other.commands;
}
