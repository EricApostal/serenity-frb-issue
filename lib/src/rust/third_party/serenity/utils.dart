// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'model/id.dart';
import 'model/timestamp.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `convert`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ChannelParseError`, `EmojiParseError`, `FormattedTimestampParseError`, `GuildChannelParseError`, `GuildParseError`, `MemberParseError`, `MessageParseError`, `RoleParseError`, `UserParseError`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `content_safe`, `parse_channel`, `parse_emoji`, `parse_quotes`, `parse_role`, `parse_username`

/// Retrieves IDs from "{channel ID}-{message ID}" (retrieved by shift-clicking on "Copy ID").
///
/// If the string is invalid, None is returned.
///
/// # Examples
/// ```rust
/// use serenity::model::prelude::*;
/// use serenity::utils::parse_message_id_pair;
///
/// assert_eq!(
///     parse_message_id_pair("673965002805477386-842482646604972082"),
///     Some((ChannelId::new(673965002805477386), MessageId::new(842482646604972082))),
/// );
/// assert_eq!(
///     parse_message_id_pair("673965002805477386-842482646604972082-472029906943868929"),
///     None,
/// );
/// ```
Future<(ChannelId, MessageId)?> parseMessageIdPair({required String s}) =>
    RustLib.instance.api.serenityUtilsParseMessageIdPair(s: s);

/// Retrieves guild, channel, and message ID from a message URL.
///
/// If the URL is malformed, None is returned.
///
/// # Examples
/// ```rust
/// use serenity::model::prelude::*;
/// use serenity::utils::parse_message_url;
///
/// assert_eq!(
///     parse_message_url(
///         "https://discord.com/channels/381880193251409931/381880193700069377/806164913558781963"
///     ),
///     Some((
///         GuildId::new(381880193251409931),
///         ChannelId::new(381880193700069377),
///         MessageId::new(806164913558781963),
///     )),
/// );
/// assert_eq!(
///     parse_message_url(
///         "https://canary.discord.com/channels/381880193251409931/381880193700069377/806164913558781963"
///     ),
///     Some((
///         GuildId::new(381880193251409931),
///         ChannelId::new(381880193700069377),
///         MessageId::new(806164913558781963),
///     )),
/// );
/// assert_eq!(parse_message_url("https://google.com"), None);
/// ```
Future<(GuildId, ChannelId, MessageId)?> parseMessageUrl({required String s}) =>
    RustLib.instance.api.serenityUtilsParseMessageUrl(s: s);

/// Retrieves the "code" part of an invite out of a URL.
///
/// # Examples
///
/// Two formats of [invite][`RichInvite`] codes are supported, both regardless of protocol prefix.
/// Some examples:
///
/// 1. Retrieving the code from the URL `"https://discord.gg/0cDvIgU2voY8RSYL"`:
///
/// ```rust
/// use serenity::utils;
///
/// let url = "https://discord.gg/0cDvIgU2voY8RSYL";
///
/// assert_eq!(utils::parse_invite(url), "0cDvIgU2voY8RSYL");
/// ```
///
/// 2. Retrieving the code from the URL `"http://discord.com/invite/0cDvIgU2voY8RSYL"`:
///
/// ```rust
/// use serenity::utils;
///
/// let url = "http://discord.com/invite/0cDvIgU2voY8RSYL";
///
/// assert_eq!(utils::parse_invite(url), "0cDvIgU2voY8RSYL");
/// ```
///
/// [`RichInvite`]: crate::model::invite::RichInvite
Future<void> parseInvite({required String code}) =>
    RustLib.instance.api.serenityUtilsParseInvite(code: code);

/// Retrieves the username and discriminator out of a user tag (`name#discrim`).
/// In order to accomodate next gen Discord usernames, this will also accept `name` style tags.
///
/// If the user tag is invalid, None is returned.
///
/// # Examples
/// ```rust
/// use std::num::NonZeroU16;
///
/// use serenity::utils::parse_user_tag;
///
/// assert_eq!(parse_user_tag("kangalioo#9108"), Some(("kangalioo", NonZeroU16::new(9108))));
/// assert_eq!(parse_user_tag("kangalioo#10108"), None);
/// assert_eq!(parse_user_tag("kangalioo"), Some(("kangalioo", None)));
/// ```
Future<(Str, NonZeroU16?)?> parseUserTag({required String s}) =>
    RustLib.instance.api.serenityUtilsParseUserTag(s: s);

/// Retrieves an Id from a user mention.
///
/// If the mention is invalid, then [`None`] is returned.
///
/// # Examples
///
/// Retrieving an Id from a valid [`User`] mention:
///
/// ```rust
/// use serenity::model::id::UserId;
/// use serenity::utils::parse_username;
///
/// // regular username mention
/// assert_eq!(parse_username("<@114941315417899012>"), Some(UserId::new(114941315417899012)));
///
/// // nickname mention
/// assert_eq!(parse_username("<@!114941315417899012>"), Some(UserId::new(114941315417899012)));
/// ```
///
/// Asserting that an invalid username or nickname mention returns [`None`]:
///
/// ```rust
/// use serenity::utils::parse_username;
///
/// assert!(parse_username("<@1149413154aa17899012").is_none());
/// assert!(parse_username("<@!11494131541789a90b1c2").is_none());
/// ```
///
/// [`User`]: crate::model::user::User
Future<UserId?> parseUserMention({required String mention}) =>
    RustLib.instance.api.serenityUtilsParseUserMention(mention: mention);

/// Retrieves an Id from a role mention.
///
/// If the mention is invalid, then [`None`] is returned.
///
/// # Examples
///
/// Retrieving an Id from a valid [`Role`] mention:
///
/// ```rust
/// use serenity::model::id::RoleId;
/// use serenity::utils::parse_role;
///
/// assert_eq!(parse_role("<@&136107769680887808>"), Some(RoleId::new(136107769680887808)));
/// ```
///
/// Asserting that an invalid role mention returns [`None`]:
///
/// ```rust
/// use serenity::utils::parse_role;
///
/// assert!(parse_role("<@&136107769680887808").is_none());
/// ```
///
/// [`Role`]: crate::model::guild::Role
Future<RoleId?> parseRoleMention({required String mention}) =>
    RustLib.instance.api.serenityUtilsParseRoleMention(mention: mention);

/// Retrieves an Id from a channel mention.
///
/// If the channel mention is invalid, then [`None`] is returned.
///
/// # Examples
///
/// Retrieving an Id from a valid [`Channel`] mention:
///
/// ```rust
/// use serenity::model::id::ChannelId;
/// use serenity::utils::parse_channel;
///
/// assert_eq!(parse_channel("<#81384788765712384>"), Some(ChannelId::new(81384788765712384)));
/// ```
///
/// Asserting that an invalid channel mention returns [`None`]:
///
/// ```rust
/// use serenity::utils::parse_channel;
///
/// assert!(parse_channel("<#!81384788765712384>").is_none());
/// assert!(parse_channel("<#81384788765712384").is_none());
/// ```
///
/// [`Channel`]: crate::model::channel::Channel
Future<ChannelId?> parseChannelMention({required String mention}) =>
    RustLib.instance.api.serenityUtilsParseChannelMention(mention: mention);

/// Parses the id and token from a webhook url. Expects a [`url::Url`] rather than a [`&str`].
///
/// # Examples
///
/// ```rust
/// use serenity::utils;
///
/// let url_str = "https://discord.com/api/webhooks/245037420704169985/ig5AO-wdVWpCBtUUMxmgsWryqgsW3DChbKYOINftJ4DCrUbnkedoYZD0VOH1QLr-S3sV";
/// let url = url_str.parse().unwrap();
/// let (id, token) = utils::parse_webhook(&url).unwrap();
///
/// assert_eq!(id, 245037420704169985);
/// assert_eq!(token, "ig5AO-wdVWpCBtUUMxmgsWryqgsW3DChbKYOINftJ4DCrUbnkedoYZD0VOH1QLr-S3sV");
/// ```
Future<(WebhookId, Str)?> parseWebhook({required Url url}) =>
    RustLib.instance.api.serenityUtilsParseWebhook(url: url);

/// Calculates the Id of the shard responsible for a guild, given its Id and total number of shards
/// used.
///
/// # Examples
///
/// Retrieve the Id of the shard for a guild with Id `81384788765712384`, using 17 shards:
///
/// ```rust
/// use serenity::model::id::GuildId;
/// use serenity::utils;
///
/// assert_eq!(utils::shard_id(GuildId::new(81384788765712384), 17), 7);
/// ```
Future<int> shardId({required GuildId guildId, required int shardCount}) =>
    RustLib.instance.api.serenityUtilsShardId(
      guildId: guildId,
      shardCount: shardCount,
    );

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContentSafeOptions>>
abstract class ContentSafeOptions implements RustOpaqueInterface {
  /// Instantiates with all options set to `true`.
  static Future<ContentSafeOptions> default_() =>
      RustLib.instance.api.serenityUtilsContentSafeOptionsDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ContentSafeOptions> newInstance() =>
      RustLib.instance.api.serenityUtilsContentSafeOptionsNew();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FormattedTimestamp>>
abstract class FormattedTimestamp implements RustOpaqueInterface {
  static Future<FormattedTimestamp> default_() =>
      RustLib.instance.api.serenityUtilsFormattedTimestampDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new [`FormattedTimestamp`] instance from the given [`Timestamp`] and
  /// [`FormattedTimestampStyle`].
  static Future<FormattedTimestamp> newInstance({
    required Timestamp timestamp,
    FormattedTimestampStyle? style,
  }) => RustLib.instance.api.serenityUtilsFormattedTimestampNew(
    timestamp: timestamp,
    style: style,
  );

  /// Creates a new [`FormattedTimestamp`] instance representing the current timestamp with the
  /// default style.
  static Future<FormattedTimestamp> now() =>
      RustLib.instance.api.serenityUtilsFormattedTimestampNow();

  /// Returns the style of this [`FormattedTimestamp`].
  Future<FormattedTimestampStyle?> style();

  /// Returns the timestamp of this [`FormattedTimestamp`].
  Future<PlatformInt64> timestamp();
}

/// Enum representing various styles for formatting time in messages.
///
/// [Discord docs](https://discord.com/developers/docs/reference#message-formatting-timestamp-styles).
enum FormattedTimestampStyle {
  /// Represents a short time format, e.g., "12:34 PM".
  shortTime,

  /// Represents a long time format, e.g., "12:34:56 PM".
  longTime,

  /// Represents a short date format, e.g., "2023-11-17".
  shortDate,

  /// Represents a long date format, e.g., "November 17, 2023".
  longDate,

  /// Represents a short date and time format, e.g., "November 17, 2023 12:34 PM".
  shortDateTime,

  /// Represents a long date and time format, e.g., "Thursday, November 17, 2023 12:34 PM".
  longDateTime,

  /// Represents a relative time format, indicating the time relative to the current moment,
  /// e.g., "2 hours ago" or "in 2 hours".
  relativeTime;

  static Future<FormattedTimestampStyle> default_() =>
      RustLib.instance.api.serenityUtilsFormattedTimestampStyleDefault();
}
