// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'model/channel/channel_id.dart';
import 'model/gateway.dart';
import 'model/id.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `event_handler_arc`, `event_handler`, `framework`, `raw_event_handler`, `type_map_insert`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `into_future`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `activity`, `builder`, `cache_settings`, `intents`, `new`, `status`, `token`, `type_map`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < String > >>>
abstract class ArcMutexString implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < RwLock < TypeMap > >>>
abstract class ArcTypeMap implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < ShardManager >>>
abstract class ArcShardManager implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>
abstract class Client implements RustOpaqueInterface {
  ArcCache get cache;

  ArcTypeMap get data;

  ArcHttp get http;

  ArcShardManager get shardManager;

  ArcMutexString get wsUrl;

  set cache(ArcCache cache);

  set data(ArcTypeMap data);

  set http(ArcHttp http);

  set shardManager(ArcShardManager shardManager);

  set wsUrl(ArcMutexString wsUrl);

  /// Establish the connection and start listening for events.
  ///
  /// This will start receiving events in a loop and start dispatching the events to your
  /// registered handlers.
  ///
  /// Note that this should be used only for users and for bots which are in less than 2500
  /// guilds. If you have a reason for sharding and/or are in more than 2500 guilds, use one of
  /// these depending on your use case:
  ///
  /// Refer to the [Gateway documentation][gateway docs] for more information on effectively
  /// using sharding.
  ///
  /// # Examples
  ///
  /// Starting a Client with only 1 shard, out of 1 total:
  ///
  /// ```rust,no_run
  /// # use std::error::Error;
  /// # use serenity::prelude::*;
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn Error>> {
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default()).await?;
  ///
  /// if let Err(why) = client.start().await {
  ///     println!("Err with client: {:?}", why);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// [gateway docs]: crate::gateway#sharding
  Future<void> start();

  /// Establish the connection(s) and start listening for events.
  ///
  /// This will start receiving events in a loop and start dispatching the events to your
  /// registered handlers.
  ///
  /// This will retrieve an automatically determined number of shards to use from the API -
  /// determined by Discord - and then open a number of shards equivalent to that amount.
  ///
  /// Refer to the [Gateway documentation][gateway docs] for more information on effectively
  /// using sharding.
  ///
  /// # Examples
  ///
  /// Start as many shards as needed using autosharding:
  ///
  /// ```rust,no_run
  /// # use std::error::Error;
  /// # use serenity::prelude::*;
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn Error>> {
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default()).await?;
  ///
  /// if let Err(why) = client.start_autosharded().await {
  ///     println!("Err with client: {:?}", why);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Errors
  ///
  /// Returns a [`ClientError::Shutdown`] when all shards have shutdown due to an error.
  ///
  /// [gateway docs]: crate::gateway#sharding
  Future<void> startAutosharded();

  /// Establish a sharded connection and start listening for events.
  ///
  /// This will start receiving events and dispatch them to your registered handlers.
  ///
  /// This will create a single shard by ID. If using one shard per process, you will need to
  /// start other processes with the other shard IDs in some way.
  ///
  /// Refer to the [Gateway documentation][gateway docs] for more information on effectively
  /// using sharding.
  ///
  /// # Examples
  ///
  /// Start shard 3 of 5:
  ///
  /// ```rust,no_run
  /// # use std::error::Error;
  /// # use serenity::prelude::*;
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn Error>> {
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default()).await?;
  ///
  /// if let Err(why) = client.start_shard(3, 5).await {
  ///     println!("Err with client: {:?}", why);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// Start shard 0 of 1 (you may also be interested in [`Self::start`] or
  /// [`Self::start_autosharded`]):
  ///
  /// ```rust,no_run
  /// # use std::error::Error;
  /// # use serenity::prelude::*;
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn Error>> {
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default()).await?;
  ///
  /// if let Err(why) = client.start_shard(0, 1).await {
  ///     println!("Err with client: {:?}", why);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Errors
  ///
  /// Returns a [`ClientError::Shutdown`] when all shards have shutdown due to an error.
  ///
  /// [gateway docs]: crate::gateway#sharding
  Future<void> startShard({required int shard, required int shards});

  /// Establish a range of sharded connections and start listening for events.
  ///
  /// This will start receiving events and dispatch them to your registered handlers.
  ///
  /// This will create and handle all shards within a given range within this single process. If
  /// you only need to start a single shard within the process, or all shards within the process,
  /// use [`Self::start_shard`] or [`Self::start_shards`], respectively.
  ///
  /// Refer to the [Gateway documentation][gateway docs] for more information on effectively
  /// using sharding.
  ///
  /// # Examples
  ///
  /// For a bot using a total of 10 shards, initialize shards 4 through 7:
  ///
  /// ```rust,no_run
  /// # use std::error::Error;
  /// # use serenity::prelude::*;
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn Error>> {
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default()).await?;
  ///
  /// if let Err(why) = client.start_shard_range(4..7, 10).await {
  ///     println!("Err with client: {:?}", why);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Errors
  ///
  /// Returns a [`ClientError::Shutdown`] when all shards have shutdown due to an error.
  ///
  /// [Gateway docs]: crate::gateway#sharding
  Future<void> startShardRange({
    required RangeU32 range,
    required int totalShards,
  });

  /// Establish sharded connections and start listening for events.
  ///
  /// This will start receiving events and dispatch them to your registered handlers.
  ///
  /// This will create and handle all shards within this single process. If you only need to
  /// start a single shard within the process, or a range of shards, use [`Self::start_shard`] or
  /// [`Self::start_shard_range`], respectively.
  ///
  /// Refer to the [Gateway documentation][gateway docs] for more information on effectively
  /// using sharding.
  ///
  /// # Examples
  ///
  /// Start all of 8 shards:
  ///
  /// ```rust,no_run
  /// # use std::error::Error;
  /// # use serenity::prelude::*;
  /// use serenity::Client;
  ///
  /// # async fn run() -> Result<(), Box<dyn Error>> {
  /// let token = std::env::var("DISCORD_TOKEN")?;
  /// let mut client = Client::builder(&token, GatewayIntents::default()).await?;
  ///
  /// if let Err(why) = client.start_shards(8).await {
  ///     println!("Err with client: {:?}", why);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Errors
  ///
  /// Returns a [`ClientError::Shutdown`] when all shards have shutdown due to an error.
  ///
  /// [Gateway docs]: crate::gateway#sharding
  Future<void> startShards({required int totalShards});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientBuilder>>
abstract class ClientBuilder implements RustOpaqueInterface {
  /// Sets the application id.
  Future<ClientBuilder> applicationId({required ApplicationId applicationId});

  /// Gets the application ID, if already initialized. See [`Self::application_id`] for more
  /// info.
  Future<ApplicationId?> getApplicationId();

  /// Gets the cache settings. See [`Self::cache_settings`] for more info.
  Future<void> getCacheSettings();

  /// Gets the added event handlers. See [`Self::event_handler`] for more info.
  Future<void> getEventHandlers();

  /// Gets the framework, if already initialized. See [`Self::framework`] for more info.
  Future<Framework?> getFramework();

  /// Gets the intents. See [`Self::intents`] for more info.
  Future<GatewayIntents> getIntents();

  /// Gets the initial presence. See [`Self::activity`] and [`Self::status`] for more info.
  Future<void> getPresence();

  /// Gets the added raw event handlers. See [`Self::raw_event_handler`] for more info.
  Future<void> getRawEventHandlers();

  /// Gets the current token used for the [`Http`] client.
  Future<void> getToken();

  /// Gets the type map. See [`Self::type_map`] for more info.
  Future<void> getTypeMap();

  /// Construct a new builder with a [`Http`] instance to calls methods on for the client
  /// construction.
  ///
  /// **Panic**: If you have enabled the `framework`-feature (on by default), you must specify a
  /// framework via the [`Self::framework`] method, otherwise awaiting the builder will cause a
  /// panic.
  static Future<ClientBuilder> newWithHttp({
    required Http http,
    required GatewayIntents intents,
  }) => RustLib.instance.api.serenityClientClientBuilderNewWithHttp(
    http: http,
    intents: intents,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Range < u32 >>>
abstract class RangeU32 implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<dyn Framework>>
abstract class Framework implements RustOpaqueInterface {}
